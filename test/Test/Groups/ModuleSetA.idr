-- NOTE: A large portion of this file was generated by AI

module Test.Groups.ModuleSetA

import Data.LLVM
import Data.LLVM.IR
import Data.LLVM.Write.Assembly
import Data.LLVM.Class
import Data.LLVM.IR.Builders.Math
import Test.Helper
import Data.LLVM.Write.Foreign

export
emptyModule : LModule
emptyModule = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [],
    tags = Nothing
}

export
moduleWithGlobals : LModule
moduleWithGlobals = MkLModule {
    
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        -- Global integer variable
        GlobalDefC $ MkGVarDef {
            name = "global_counter",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = True,
            gtpe = LInt 32,
            initializer = Just (LInt 42),
            tags = []
        },
        -- Global constant string
        GlobalDefC $ MkGVarDef {
            name = "hello_string",
            symbolInfo = MkSymbolInfo (Just Private) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = True,
            gtpe = LArray 13 (LInt 8),
            initializer = Just (LString "Hello, World!\\00"),
            tags = []
        }
    ],
    tags = Nothing
}

export
moduleWithSimpleFunction : LModule
moduleWithSimpleFunction = MkLModule {
    
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "simple_add",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkFunctionArgSpec (LInt 32) [] (Just "a"),
                MkFunctionArgSpec (LInt 32) [] (Just "b")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBlock "entry" [
                    Operation (Assign (NamedRegister "result")) (BinaryOp Add (LInt 32) (LVar (Local (NamedRegister "a"))) (LVar (Local (NamedRegister "b"))))
                ] (Ret (LInt 32) (LVar (Local (NamedRegister "result"))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

export
moduleWithOperations : LModule
moduleWithOperations = MkLModule {
    
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "main",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkFunctionArgSpec (LInt 32) [] (Just "x"),
                MkFunctionArgSpec (LInt 32) [] (Just "y")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBlock "entry" [
                    -- Multiply x and y
                    Operation (Assign (NamedRegister "mul_result")) (BinaryOp Mul (LInt 32) (LVar (Local (NamedRegister "x"))) (LVar (Local (NamedRegister "y")))),
                    -- Add 10 to the result
                    Operation (Assign (NamedRegister "add_result")) (BinaryOp Add (LInt 32) (LVar (Local (NamedRegister "mul_result"))) (LConstE (LInt 10))),
                    -- Shift left by 1
                    Operation (Assign (NamedRegister "shift_result")) (BinaryOp Shl (LInt 32) (LVar (Local (NamedRegister "add_result"))) (LConstE (LInt 1)))
                ] (Ret (LInt 32) (LVar (Local (NamedRegister "shift_result"))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

export
completeModule : LModule
completeModule = MkLModule {
    
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        -- Global array
        GlobalDefC $ MkGVarDef {
            name = "data_array",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = True,
            gtpe = LArray 5 (LInt 32),
            initializer = Just (LArray [MkWithType (LInt 32) (LInt 1), MkWithType (LInt 32) (LInt 2), MkWithType (LInt 32) (LInt 3), MkWithType (LInt 32) (LInt 4), MkWithType (LInt 32) (LInt 5)]),
            tags = []
        },
        -- Main function
        FunctionDefC $ MkFunctionDef {
            name = "main",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkFunctionArgSpec (LInt 32) [] (Just "argc"),
                MkFunctionArgSpec LPtr [] (Just "argv")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBlock "entry" [
                    -- Allocate local variable
                    Operation (Assign (NamedRegister "local_var")) (MemoryOp (Alloc (LInt 32) Nothing Nothing Nothing)),
                    -- Call helper function
                    Operation (Assign (NamedRegister "call_result")) (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing (LFun (LInt 32) [LInt 32, LInt 32]) (LConstE (LPtr (Global "helper_function"))) [MkWithType (LInt 32) (LConstE (LInt 5)), MkWithType (LInt 32) (LConstE (LInt 10))] []))),
                    -- Compare i32 result with 0 to produce i1 for conditional branch
                    Operation (Assign (NamedRegister "cond")) (icmp CEq (LInt 32) (LVar (Local (NamedRegister "call_result"))) (LConstE (LInt 0)))
                ] (CondBr (LVar (Local (NamedRegister "cond"))) (LVar (LabelN "success_block")) (LVar (LabelN "failure_block"))),
                
                MkBlock "success_block" [
                ] (Ret (LInt 32) (LConstE (LInt 0))),
                
                MkBlock "failure_block" [
                ] (Ret (LInt 32) (LConstE (LInt 1)))
            ],
            tags = []
        },
        -- Helper function
        FunctionDefC $ MkFunctionDef {
            name = "helper_function",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkFunctionArgSpec (LInt 32) [] (Just "a"),
                MkFunctionArgSpec (LInt 32) [] (Just "b")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBlock "entry" [
                    -- Perform various operations
                    Operation (Assign (NamedRegister "sum")) (BinaryOp Add (LInt 32) (LVar (Local (NamedRegister "a"))) (LVar (Local (NamedRegister "b")))),
                    Operation (Assign (NamedRegister "diff")) (BinaryOp Sub (LInt 32) (LVar (Local (NamedRegister "a"))) (LVar (Local (NamedRegister "b")))),
                    Operation (Assign (NamedRegister "product")) (BinaryOp Mul (LInt 32) (LVar (Local (NamedRegister "sum"))) (LVar (Local (NamedRegister "diff")))),
                    -- Use aggregate operation
                    Operation (Assign (NamedRegister "array_val")) (AggregateOp (ExtractValue (MkWithType (LArray 5 (LInt 32)) (LConstE (LPtr (Global "data_array")))) 0)),
                    Operation (Assign (NamedRegister "final_result")) (BinaryOp Add (LInt 32) (LVar (Local (NamedRegister "product"))) (LVar (Local (NamedRegister "array_val"))))
                ] (Ret (LInt 32) (LVar (Local (NamedRegister "final_result"))))
            ],
            tags = []
        },
    
        -- External function declaration
        FunctionDecC $ MkFunctionDec {
            name = "printf",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec LPtr [] Nothing],
            addressInfo = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            tags = []
        }
    ],
    tags = Nothing
}

export
-- Module with thread-local storage and address spaces
moduleWithTLS : LModule
moduleWithTLS = MkLModule {
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        -- Thread-local variable
        GlobalDefC $ MkGVarDef {
            name = "tls_counter",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Just LocalDynamic,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LInt 32,
            initializer = Just (LInt 0),
            tags = []
        },
        -- Global in specific address space
        GlobalDefC $ MkGVarDef {
            name = "gpu_memory",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Just (UnnamedSpace 1),
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LArray 1024 (LInt 8),
            initializer = Nothing,
            tags = []
        }
    ],
    tags = Nothing
}
export
-- Module with various calling conventions
moduleWithCallingConventions : LModule
moduleWithCallingConventions = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Error format string
        GlobalDefC $ MkGVarDef {
            name = "error_format",
            symbolInfo = MkSymbolInfo (Just Private) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LArray 15 (LInt 8),
            initializer = Just (LString "Error: %d\\0a\\00"),
            tags = []
        },
        -- Fast calling convention function
        FunctionDefC $ MkFunctionDef {
            name = "fast_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just Fast,
            returnAttrs = [],
            returnType = LFloating LFloat,
            args = [
                MkFunctionArgSpec (LFloating LFloat) [] (Just "x"),
                MkFunctionArgSpec (LFloating LFloat) [] (Just "y")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBlock "entry" [
                    Operation (Assign (NamedRegister "result")) (BinaryOp (FAdd []) (LFloating LFloat) (LVar (Local (NamedRegister "x"))) (LVar (Local (NamedRegister "y"))))
                ] (Ret (LFloating LFloat) (LVar (Local (NamedRegister "result"))))
            ],
            tags = []
        },
        -- Cold calling convention function (rarely called)
        FunctionDefC $ MkFunctionDef {
            name = "error_handler",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            callingConvention = Just Cold,
            returnAttrs = [],
            returnType = LVoid,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "error_code")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBlock "entry" [
                    -- Call printf to report error
                    Operation (Assign (NamedRegister "printf_result")) (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                        (LFun (LInt 32) [LPtr]) 
                        (LConstE (LPtr (Global "printf"))) 
                        [MkWithType LPtr (LConstE (LPtr (Global "error_format")))] [])))
                ] RetVoid
            ],
            tags = []
        }
    ],
    tags = Nothing
}

export
-- Module with vector operations
moduleWithVectors : LModule
moduleWithVectors = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "vector_operations",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LVector 4 (LInt 32),
            args = [
                MkFunctionArgSpec (LVector 4 (LInt 32)) [] (Just "vec1"),
                MkFunctionArgSpec (LVector 4 (LInt 32)) [] (Just "vec2")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBlock "entry" [
                    -- Extract element from first vector
                    Operation (Assign (NamedRegister "elem1")) (VectorOp (ExtractElement 
                        (MkWithType (LVector 4 (LInt 32)) (LVar (Local (NamedRegister "vec1"))))
                        (MkWithType (LInt 32) (LConstE (LInt 0))))),
                    -- Insert element into second vector
                    Operation (Assign (NamedRegister "modified_vec")) (VectorOp (InsertElement 
                        (MkWithType (LVector 4 (LInt 32)) (LVar (Local (NamedRegister "vec2"))))
                        (MkWithType (LInt 32) (LVar (Local (NamedRegister "elem1"))))
                        (MkWithType (LInt 32) (LConstE (LInt 1))))),
                    -- Shuffle vectors
                    Operation (Assign (NamedRegister "shuffled")) (VectorOp (ShuffleVector
                        (MkWithType (LVector 4 (LInt 32)) (LVar (Local (NamedRegister "vec1"))))
                        (MkWithType (LVector 4 (LInt 32)) (LVar (Local (NamedRegister "modified_vec"))))
                        (MkWithType (LVector 4 (LInt 32)) (LConstE (LVector [
                            MkWithType (LInt 32) (LInt 0),
                            MkWithType (LInt 32) (LInt 5),
                            MkWithType (LInt 32) (LInt 2),
                            MkWithType (LInt 32) (LInt 7)
                        ])))))
                ] (Ret (LVector 4 (LInt 32)) (LVar (Local (NamedRegister "shuffled"))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

export
-- Module with control flow and phi nodes
moduleWithControlFlow : LModule
moduleWithControlFlow = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "fibonacci",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "n")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBlock "entry" [
                    -- Check if n <= 1 (use proper comparison)
                    Operation (Assign (NamedRegister "cmp")) (icmp CSLe (LInt 32) (LVar (Local (NamedRegister "n"))) (LConstE (LInt 1)))
                ] (CondBr (LVar (Local (NamedRegister "cmp"))) (LVar (LabelN "base_case")) (LVar (LabelN "recursive_case"))),
                
                MkBlock "base_case" [
                ] (Ret (LInt 32) (LVar (Local (NamedRegister "n")))),
                
                MkBlock "recursive_case" [
                    -- Calculate fib(n-1)
                    Operation (Assign (NamedRegister "n_minus_1")) (BinaryOp Sub (LInt 32) (LVar (Local (NamedRegister "n"))) (LConstE (LInt 1))),
                    Operation (Assign (NamedRegister "fib_n_minus_1")) (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                        (LFun (LInt 32) [LInt 32]) 
                        (LConstE (LPtr (Global "fibonacci"))) 
                        [MkWithType (LInt 32) (LVar (Local (NamedRegister "n_minus_1")))] []))),
                    -- Calculate fib(n-2)
                    Operation (Assign (NamedRegister "n_minus_2")) (BinaryOp Sub (LInt 32) (LVar (Local (NamedRegister "n"))) (LConstE (LInt 2))),
                    Operation (Assign (NamedRegister "fib_n_minus_2")) (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                        (LFun (LInt 32) [LInt 32]) 
                        (LConstE (LPtr (Global "fibonacci"))) 
                        [MkWithType (LInt 32) (LVar (Local (NamedRegister "n_minus_2")))] []))),
                    -- Add results
                    Operation (Assign (NamedRegister "result")) (BinaryOp Add (LInt 32) (LVar (Local (NamedRegister "fib_n_minus_1"))) (LVar (Local (NamedRegister "fib_n_minus_2"))))
                ] (Ret (LInt 32) (LVar (Local (NamedRegister "result"))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

export
-- Module with switch statements and multiple cases
moduleWithSwitch : LModule
moduleWithSwitch = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "handle_opcode",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "opcode")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBlock "entry" [
                ] (Switch (LInt 32) (LVar (Local (NamedRegister "opcode"))) (LabelN "default") [
                    MkCaseBranch (LInt 32) (LConstE (LInt 1)) (LVar (LabelN "case_add")),
                    MkCaseBranch (LInt 32) (LConstE (LInt 2)) (LVar (LabelN "case_sub")),
                    MkCaseBranch (LInt 32) (LConstE (LInt 3)) (LVar (LabelN "case_mul")),
                    MkCaseBranch (LInt 32) (LConstE (LInt 4)) (LVar (LabelN "case_div"))
                ]),
                
                MkBlock "case_add" [
                ] (Ret (LInt 32) (LConstE (LInt 100))),
                
                MkBlock "case_sub" [
                ] (Ret (LInt 32) (LConstE (LInt 200))),
                
                MkBlock "case_mul" [
                ] (Ret (LInt 32) (LConstE (LInt 300))),
                
                MkBlock "case_div" [
                ] (Ret (LInt 32) (LConstE (LInt 400))),
                
                MkBlock "default" [
                ] (Ret (LInt 32) (LConstE (LInt (-1))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}
{- 
-- Module with struct operations and complex types
moduleWithStructs : LModule
moduleWithStructs = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Global struct
        GlobalDefC $ MkGVarDef {
            name = "global_point",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LStruct [LInt 32, LInt 32],
            initializer = Just (LStruct [MkWithType (LInt 32) (LInt 10), MkWithType (LInt 32) (LInt 20)]),
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "struct_operations",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LStruct [LInt 32, LInt 32]) [] (Just "point")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock "entry" [
                -- Extract x coordinate
                Operation (Local "x") (AggregateOp (ExtractValue 
                    (MkWithType (LStruct [LInt 32, LInt 32]) (LConstE (LPtr (Local "point")))) 0)),
                -- Extract y coordinate
                Operation (Local "y") (AggregateOp (ExtractValue 
                    (MkWithType (LStruct [LInt 32, LInt 32]) (LConstE (LPtr (Local "point")))) 1)),
                -- Calculate sum
                Operation (Local "sum") (BinaryOp Add (LInt 32) (LConstE (LPtr (Local "x"))) (LConstE (LPtr (Local "y")))),
                -- Create new struct with modified values
                Operation (Local "new_point") (AggregateOp (InsertValue 
                    (MkWithType (LStruct [LInt 32, LInt 32]) (LConstE (LPtr (Local "point"))))
                    (MkWithType (LInt 32) (LConstE (LPtr (Local "sum"))))
                    0))
            ] (Ret (LInt 32) (LConstE (LPtr (Local "sum")))))],
            tags = []
        }
    ],
    tags = Nothing
}
-}
-- Module with aliases and IFuncs
export
moduleWithAliases : LModule
moduleWithAliases = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Function to be aliased
        FunctionDefC $ MkFunctionDef {
            name = "original_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "x")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock "entry" [
                Operation (Assign (NamedRegister "result")) (BinaryOp Mul (LInt 32) (LVar (Local (NamedRegister "x"))) (LConstE (LInt 2)))
            ] (Ret (LInt 32) (LVar (Local (NamedRegister "result"))))],
            tags = []
        },
        -- Alias to the function
        AliasC $ MkAlias {
            name = "function_alias",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            aliasTpe = LFun (LInt 32) [LInt 32],
            aliasee = "original_function",
            tags = []
        },
        -- IFunc with resolver
        IFuncC $ MkIFunc {
            name = "dynamic_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            funTpe = LFun (LInt 32) [LInt 32],
            resTpe = LPtr,
            resolver = "function_resolver",
            tags = []
        }
    ],
    tags = Nothing
}

export
-- Module with exception handling and personality functions
moduleWithExceptions : LModule
moduleWithExceptions = MkLModule {
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        -- Declare exception handling personality function
        FunctionDecC $ MkFunctionDec {
            name = "__gxx_personality_v0",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] Nothing, MkFunctionArgSpec (LInt 32) [] Nothing, MkFunctionArgSpec (LInt 64) [] Nothing, MkFunctionArgSpec LPtr [] Nothing, MkFunctionArgSpec LPtr [] Nothing],
            addressInfo = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "exception_test",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "x")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Just (LPtr (Global "__gxx_personality_v0")),
            metadata = [],
            body = [
                MkBlock "entry" [
                    -- Invoke that might throw
                    Operation (Assign (NamedRegister "result")) (TerminatorOp (Invoke (MkInvokeCall (Just C) [] Nothing 
                        (LFun (LInt 32) [LInt 32]) 
                        (LConstE (LPtr (Global "might_throw"))) 
                        [LVar (Local (NamedRegister "x"))]
                        (LVar (LabelN "normal"))
                        (LVar (LabelN "exception")))))
                ] (JumpBr (LVar (LabelN "normal"))),
                
                MkBlock "normal" [
                ] (Ret (LInt 32) (LVar (Local (NamedRegister "result")))),
                
                MkBlock "exception" [
                    -- Landing pad for exception handling (simplified for demo)
                    Operation (Assign (NamedRegister "landing_pad")) (BinaryOp Add (LInt 32) (LConstE (LInt 0)) (LConstE (LInt 0)))
                ] (Ret (LInt 32) (LConstE (LInt (-1))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

export
-- Module with atomic operations and memory ordering
moduleWithAtomics : LModule
moduleWithAtomics = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Global atomic counter
        GlobalDefC $ MkGVarDef {
            name = "atomic_counter",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LInt 32,
            initializer = Just (LInt 0),
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "atomic_operations",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "value")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock "entry" [
                -- Simple memory operations using MemoryOp variants
                Operation (Assign (NamedRegister "old_value")) (MemoryOp (LoadRegular False (LInt 32)
                    (LConstE (LPtr (Global "atomic_counter")))
                    Nothing False False False False Nothing Nothing Nothing False)),
                -- Store atomic value
                Operation Discard (MemoryOp (StoreRegular False
                    (MkWithType (LInt 32) (LVar (Local (NamedRegister "value"))))
                    (LConstE (LPtr (Global "atomic_counter")))
                    Nothing False False)),
                -- Memory fence
                Operation Discard (MemoryOp (Fence Nothing (Just SequentiallyConsistent)))
            ] (Ret (LInt 32) (LVar (Local (NamedRegister "old_value"))))],
            tags = []
        }
    ],
    tags = Nothing
}

export
-- Module with inline assembly
moduleWithInlineAssembly : LModule
moduleWithInlineAssembly = MkLModule {
    dataLayout = Nothing,
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "inline_asm_test",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkFunctionArgSpec (LInt 32) [] (Just "a"),
                MkFunctionArgSpec (LInt 32) [] (Just "b")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock "entry" [
                -- Inline assembly to add two numbers (simplified for demo)
                Operation (Assign (NamedRegister "result")) (BinaryOp Add (LInt 32) (LVar (Local (NamedRegister "a"))) (LVar (Local (NamedRegister "b"))))
            ] (Ret (LInt 32) (LVar (Local (NamedRegister "result"))))],
            tags = []
        }
    ],
    tags = Nothing
}

export
-- Module with debug information and metadata
moduleWithDebugInfo : LModule
moduleWithDebugInfo = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "debug_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "param")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock "entry" [
                -- Allocate local variable
                Operation (Assign (NamedRegister "local_var_ptr")) (MemoryOp (Alloc (LInt 32) Nothing Nothing Nothing)),
                -- Calculate the value
                Operation (Assign (NamedRegister "local_var")) (BinaryOp Add (LInt 32) (LVar (Local (NamedRegister "param"))) (LConstE (LInt 1))),
                -- Store the value
                Operation Discard (MemoryOp (StoreRegular False 
                    (MkWithType (LInt 32) (LVar (Local (NamedRegister "local_var"))))
                    (LVar (Local (NamedRegister "local_var_ptr")))
                    Nothing False False)),
                -- Call debug intrinsic with pointer
                Operation Discard (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun LVoid [LPtr, LPtr, LPtr]) 
                    (LConstE (LPtr (Global "llvm.dbg.declare"))) 
                    [
                        MkWithType LPtr (LVar (Local (NamedRegister "local_var_ptr"))),
                        MkWithType LPtr (LConstE LNull),
                        MkWithType LPtr (LConstE LNull)
                    ] [])))
            ] (Ret (LInt 32) (LVar (Local (NamedRegister "local_var"))))],
            tags = []
        }
    ],
    tags = Nothing
}

export
-- Module with complex nested structures and packed types
moduleWithComplexTypes : LModule
moduleWithComplexTypes = MkLModule {
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Nothing,
    text = [
        -- Complex nested struct type
        GlobalDefC $ MkGVarDef {
            name = "complex_struct",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LStruct [
                LInt 8,  -- flags
                LPackedStruct [LInt 16, LInt 16],  -- packed coordinates
                LArray 10 (LFloating LDouble),    -- array of doubles
                LStruct [                         -- nested struct
                    LPtr,                         -- pointer
                    LVector 4 (LInt 32),         -- vector
                    LFun LVoid [LInt 32]         -- function pointer
                ]
            ],
            initializer = Nothing,
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "process_complex_type",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LVoid,
            args = [MkFunctionArgSpec LPtr [] (Just "complex_ptr")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock "entry" [
                -- Get element pointer using a simpler approach
                Operation (Assign (NamedRegister "nested_ptr")) (AggregateOp (ExtractValue
                    (MkWithType (LStruct [
                        LInt 8,  -- flags
                        LPackedStruct [LInt 16, LInt 16],  -- packed coordinates
                        LArray 10 (LFloating LDouble),    -- array of doubles
                        LStruct [                         -- nested struct
                            LPtr,                         -- pointer
                            LVector 4 (LInt 32),         -- vector
                            LFun LVoid [LInt 32]         -- function pointer
                        ]
                    ]) (LVar (Local (NamedRegister "complex_ptr")))) 3)),
                -- Extract vector from nested struct
                Operation (Assign (NamedRegister "vector_ptr")) (AggregateOp (ExtractValue
                    (MkWithType (LStruct [LPtr, LVector 4 (LInt 32), LFun LVoid [LInt 32]]) 
                     (LVar (Local (NamedRegister "nested_ptr")))) 1)),
                -- Load the vector using simple load
                Operation (Assign (NamedRegister "vector")) (MemoryOp (LoadRegular False (LVector 4 (LInt 32))
                    (LVar (Local (NamedRegister "vector_ptr")))
                    Nothing False False False False Nothing Nothing Nothing False))
            ] RetVoid],
            tags = []
        }
    ],
    tags = Nothing
}

