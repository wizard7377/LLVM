-- NOTE: A large portion of this file was generated by AI
-- TODO: Finish converting to builder / op api
module Test.Groups.ModuleSetA

import Data.LLVM
import Data.LLVM.IR
import Data.LLVM.Write.Text.Encode
import Data.LLVM.Class
import Data.LLVM.Builders.Math
import Test.Helper
import Data.LLVM.Write.Foreign
import Data.LLVM.Builders.Sugar
import Data.Table
%default partial
export
emptyModule : LModule
emptyModule = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [],
    tags = neutral
}

export
moduleWithGlobals : LModule
moduleWithGlobals = MkLModule {
    
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        -- Global integer variable
        GlobalDefC $ MkGVarDef {
            name = "global_counter",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = True,
            gtpe = LInt 32,
            initializer = Just (LInt 42),
            tags = neutral
        },
        -- Global constant string
        GlobalDefC $ MkGVarDef {
            name = "hello_string",
            symbolInfo = MkSymbolInfo (Just Private) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = True,
            gtpe = LArray 13 (LInt 8),
            initializer = Just (LString "Hello, World!\\00"),
            tags = neutral
        }
    ],
    tags = neutral
}

export
moduleWithSimpleFunction : LModule
moduleWithSimpleFunction = MkLModule {
    
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "simple_add",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkArgument (:# 32) [] (Just "a"),
                MkArgument (:# 32) [] (Just "b")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkPair "entry" $ MkBasicBlock [
                    "result" $<- (Add (:# 32) (?^ "a") (?^ "b"))
                ] (Ret (:# 32) (?% "result"))
            ],
            tags = neutral
        }
    ],
    tags = neutral
}

export
moduleWithMkLStatements : LModule
moduleWithMkLStatements = MkLModule {
    
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "main",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkArgument (:# 32) [] (Just "x"),
                MkArgument (:# 32) [] (Just "y")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkPair "entry" $ MkBasicBlock [
                    -- Multiply x and y
                    "mul_result" $<- (Mul (:# 32) (?^ "x") (?^ "y")),
                    -- Add 10 to the result
                    "add_result" $<- (Add (:# 32) (?% "mul_result") (## 10)),
                    -- Shift left by 1
                    "shift_result" $<- (Shl (:# 32) (?% "add_result") (## 1))
                ] (Ret (:# 32) (?% "shift_result"))
            ],
            tags = neutral
        }
    ],
    tags = neutral
}
export
moduleWithMkLStatementsLifted : LModule
moduleWithMkLStatementsLifted = MkLModule {
    
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "main",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkArgument (:# 32) [] (Just "x"),
                MkArgument (:# 32) [] (Just "y")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkPair "entry" $ MkBasicBlock [
                    "add_result" $<- (Add (:# 32) (#! (Mul (:# 32) (?^ "x") (?^ "y"))) (## 10)),
                    -- Shift left by 1
                    "shift_result" $<- (Shl (:# 32) (?% "add_result") (## 1))
                ] (Ret (:# 32) (?% "shift_result"))
            ],
            tags = neutral
        }
    ],
    tags = neutral
}

export
completeModule : LModule
completeModule = MkLModule {
    
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        -- Global array
        GlobalDefC $ MkGVarDef {
            name = "data_array",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = True,
            gtpe = LArray 5 (:# 32),
            initializer = Just (LArray [MkWithType (:# 32) (## 1), MkWithType (:# 32) (## 2), MkWithType (:# 32) (## 3), MkWithType (:# 32) (## 4), MkWithType (:# 32) (## 5)]),
            tags = neutral
        },
        -- Main function
        FunctionDefC $ MkFunctionDef {
            name = "main",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkArgument (:# 32) [] (Just "argc"),
                MkArgument LPtr [] (Just "argv")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkPair "entry" $ MkBasicBlock [
                    -- Allocate local variable
                    "local_var" $<- ((Alloc (:# 32) Nothing Nothing Nothing)),
                    -- Call helper function
                    "call_result" $<- ((FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing (LFun (:# 32) [:# 32, :# 32]) (id (LVar (Global "helper_function"))) [MkWithType (:# 32) (## 5), MkWithType (:# 32) (## 10)] []))),
                    -- Compare i32 result with 0 to produce i1 for conditional branch
                    "cond" $<- (icmp CEq (:# 32) (?^ "call_result") (## 0))
                ] (CondBr (?^ "cond") (#^ "success_block") (#^ "failure_block")),
                
                MkPair "success_block" $ MkBasicBlock [
                ] (Ret (:# 32) (## 0)),
                
                MkPair "failure_block" $ MkBasicBlock [
                ] (Ret (:# 32) (## 1))
            ],
            tags = neutral
        },
        -- Helper function
        FunctionDefC $ MkFunctionDef {
            name = "helper_function",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkArgument (:# 32) [] (Just "a"),
                MkArgument (:# 32) [] (Just "b")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkPair "entry" $ MkBasicBlock [
                    -- Perform various operations
                    "sum" $<- (Add (:# 32) (?^ "a") (?^ "b")),
                    "diff" $<- (Sub (:# 32) (?^ "a") (?^ "b")),
                    "product" $<- (Mul (:# 32) (?^ "sum") (?^ "diff")),
                    -- Use aggregate operation
                    "array_val" $<- ((ExtractValue (MkWithType (LArray 5 (:# 32)) (id (LVar (Global "data_array")))) 0)),
                    "final_result" $<- (Add (:# 32) (?^ "product") (?^ "array_val"))
                ] (Ret (:# 32) (?^ "final_result"))
            ],
            tags = neutral
        },
    
        -- External function declaration
        FunctionDecC $ MkFunctionDec {
            name = "printf",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkArgument LPtr [] Nothing],
            addressInfo = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            tags = neutral
        }
    ],
    tags = neutral
}

export
-- Module with thread-local storage and address spaces
moduleWithTLS : LModule
moduleWithTLS = MkLModule {
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        -- Thread-local variable
        GlobalDefC $ MkGVarDef {
            name = "tls_counter",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Just LocalDynamic,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LInt 32,
            initializer = Just (LInt 0),
            tags = neutral
        },
        -- Global in specific address space
        GlobalDefC $ MkGVarDef {
            name = "gpu_memory",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Just (UnnamedSpace 1),
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LArray 1024 (LInt 8),
            initializer = Nothing,
            tags = neutral
        }
    ],
    tags = neutral
}
export
-- Module with various calling conventions
moduleWithCallingConventions : LModule
moduleWithCallingConventions = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Error format string
        GlobalDefC $ MkGVarDef {
            name = "error_format",
            symbolInfo = MkSymbolInfo (Just Private) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LArray 13 (LInt 8),
            initializer = Just (LString "Error: %d\\0a\\00"),
            tags = neutral
        },
        -- Fast calling convention function
        FunctionDefC $ MkFunctionDef {
            name = "fast_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just Fast,
            returnAttrs = [],
            returnType = LFloating LFloat,
            args = [
                MkArgument (LFloating LFloat) [] (Just "x"),
                MkArgument (LFloating LFloat) [] (Just "y")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkPair "entry" $ MkBasicBlock [
                    "result" $<- ((FAdd []) (LFloating LFloat) (?^ "x") (?^ "y"))
                ] (Ret (LFloating LFloat) (?^ "result"))
            ],
            tags = neutral
        },
        -- Cold calling convention function (rarely called)
        FunctionDefC $ MkFunctionDef {
            name = "error_handler",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            callingConvention = Just Cold,
            returnAttrs = [],
            returnType = LVoid,
            args = [MkArgument (:# 32) [] (Just "error_code")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkPair "entry" $ MkBasicBlock [
                    -- Call printf to report error
                    "printf_result" $<- ((FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                        (LFun (:# 32) [LPtr]) 
                        (id (LVar (Global "printf"))) 
                        [MkWithType LPtr (id (LVar (Global "error_format")))] [])))
                ] RetVoid
            ],
            tags = neutral
        }
    ],
    tags = neutral
}

export
-- Module with vector operations
moduleWithVectors : LModule
moduleWithVectors = ModuleSetA.emptyModule
{-- 
moduleWithVectors = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "vector_operations",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LVector 4 (:# 32),
            args = [
                MkArgument (LVector 4 (:# 32)) [] (Just "vec1"),
                MkArgument (LVector 4 (:# 32)) [] (Just "vec2")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkPair "entry" $ MkBasicBlock [
                    -- Extract element from first vector
                    "elem1" $<- ((ExtractElement 
                        ( ( 4 :<> (:# 32)) <::> (?^ "vec1"))
                        ( (:# 32) <::> (## 0)))),
                    -- Insert element into second vector
                    "modified_vec" $<- ((InsertElement 
                        ( ( 4 :<> (:# 32)) <::> (?^ "vec2"))
                        ( (:# 32) <::> (?^ "elem1"))
                        ( (:# 32) <::> (## 1)))),
                    -- Shuffle vectors
                    "shuffled" $<- ((ShuffleVector
                        ( ( 4 :<> (:# 32)) <::> (?^ "vec1"))
                        ( ( 4 :<> (:# 32)) <::> (?^ "modified_vec"))
                        ( ( 4 :<> (:# 32)) <::> (id (LVector [
                             (:# 32) <::> (## 0),
                             (:# 32) <::> (## 5),
                             (:# 32) <::> (## 2),
                             (:# 32) <::> (## 7)
                        ])))))
                ] (Ret (LVector 4 (:# 32)) (?^ "shuffled"))
            ],
            tags = neutral
        }
    ],
    tags = neutral
}
-}
export
-- Module with control flow and phi nodes
moduleWithControlFlow : LModule
moduleWithControlFlow = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "fibonacci",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkArgument (:# 32) [] (Just "n")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkPair "entry" $ MkBasicBlock [
                    -- Check if n <= 1 (use proper comparison)
                    "cmp" $<- (icmp CSLe (:# 32) (?^ "n") (## 1))
                ] (CondBr (?^ "cmp") (#^ "base_case") (#^ "recursive_case")),
                
                MkPair "base_case" $ MkBasicBlock [
                ] (Ret (:# 32) (?^ "n")),
                
                MkPair "recursive_case" $ MkBasicBlock [
                    -- Calculate fib(n-1)
                    "n_minus_1" $<- (Sub (:# 32) (?^ "n") (## 1)),
                    "fib_n_minus_1" $<- ((FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                        (LFun (:# 32) [LInt 32]) 
                        (id (LVar (Global "fibonacci"))) 
                        [MkWithType (:# 32) (?^ "n_minus_1")] []))),
                    -- Calculate fib(n-2)
                    "n_minus_2" $<- (Sub (:# 32) (?^ "n") (## 2)),
                    "fib_n_minus_2" $<- ((FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                        (LFun (:# 32) [LInt 32]) 
                        (id (LVar (Global "fibonacci"))) 
                        [MkWithType (:# 32) (?^ "n_minus_2")] []))),
                    -- Add results
                    "result" $<- (Add (:# 32) (?^ "fib_n_minus_1") (?^ "fib_n_minus_2"))
                ] (Ret (:# 32) (?^ "result"))
            ],
            tags = neutral
        }
    ],
    tags = neutral
}
export 
moduleWithIntrinsics : LModule 
moduleWithIntrinsics = 
    mkModule [
        IntrinsicDecC (intrinsicDec ("memcpy" ?+ [LPtr, LPtr, :# 32]) LVoid [!^^ ptr, !^^ ptr, !^^ (:# 32), !^^ (:# 1)]),
        FunctionDefC (functionDef "main" LVoid (["dest" !^ ptr, "src" !^ ptr, "len" !^ (:# 32)]) ["entry" !: ([
            $<< (CallIntrinsic ("memcpy" ?+ [LPtr, LPtr, :# 32]) LVoid ([(?^ "dest") <:> ptr, (?^ "src") <:> ptr, (?^ "len") <:> i32, (## 0) <:> i1]))
        ], RetVoid)])
        
    ]

