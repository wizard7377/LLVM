-- NOTE: A large portion of this file was generated by AI
-- TODO: Finish converting to builder / op api
module Test.Groups.ModuleSetA

import Data.LLVM
import Data.LLVM.IR
import Data.LLVM.Write.Assembly
import Data.LLVM.Class
import Data.LLVM.IR.Builders.Math
import Test.Helper
import Data.LLVM.Write.Foreign
import Data.LLVM.IR.Builders.Sugar
%default partial
export
emptyModule : LModule
emptyModule = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [],
    tags = Nothing
}

export
moduleWithGlobals : LModule
moduleWithGlobals = MkLModule {
    
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        -- Global integer variable
        GlobalDefC $ MkGVarDef {
            name = "global_counter",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = True,
            gtpe = LInt 32,
            initializer = Just (LInt 42),
            tags = []
        },
        -- Global constant string
        GlobalDefC $ MkGVarDef {
            name = "hello_string",
            symbolInfo = MkSymbolInfo (Just Private) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = True,
            gtpe = LArray 13 (LInt 8),
            initializer = Just (LString "Hello, World!\\00"),
            tags = []
        }
    ],
    tags = Nothing
}

export
moduleWithSimpleFunction : LModule
moduleWithSimpleFunction = MkLModule {
    
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "simple_add",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkArgument (LInt 32) [] (Just "a"),
                MkArgument (LInt 32) [] (Just "b")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBasicBlock "entry" [
                    "result" $<- (Add (:# 32) (?^ "a") (?^ "b"))
                ] (Ret (:# 32) (?% "result"))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

export
moduleWithMkLStatements : LModule
moduleWithMkLStatements = MkLModule {
    
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "main",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkArgument (LInt 32) [] (Just "x"),
                MkArgument (LInt 32) [] (Just "y")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBasicBlock "entry" [
                    -- Multiply x and y
                    "mul_result" $<- (Mul (:# 32) (?^ "x") (?^ "y")),
                    -- Add 10 to the result
                    "add_result" $<- (Add (:# 32) (?% "mul_result") (LConstE (LInt 10))),
                    -- Shift left by 1
                    "shift_result" $<- (Shl (:# 32) (?% "add_result") (LConstE (LInt 1)))
                ] (Ret (:# 32) (?% "shift_result"))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

export
completeModule : LModule
completeModule = MkLModule {
    
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        -- Global array
        GlobalDefC $ MkGVarDef {
            name = "data_array",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = True,
            gtpe = LArray 5 (LInt 32),
            initializer = Just (LArray [MkWithType (LInt 32) (LInt 1), MkWithType (LInt 32) (LInt 2), MkWithType (LInt 32) (LInt 3), MkWithType (LInt 32) (LInt 4), MkWithType (LInt 32) (LInt 5)]),
            tags = []
        },
        -- Main function
        FunctionDefC $ MkFunctionDef {
            name = "main",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkArgument (LInt 32) [] (Just "argc"),
                MkArgument LPtr [] (Just "argv")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBasicBlock "entry" [
                    -- Allocate local variable
                    "local_var" $<- ((Alloc (LInt 32) Nothing Nothing Nothing)),
                    -- Call helper function
                    "call_result" $<- ((FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing (LFun (LInt 32) [LInt 32, LInt 32]) (LConstE (LPtr (Global "helper_function"))) [MkWithType (LInt 32) (LConstE (LInt 5)), MkWithType (LInt 32) (LConstE (LInt 10))] []))),
                    -- Compare i32 result with 0 to produce i1 for conditional branch
                    "cond" $<- (icmp CEq (LInt 32) (?^ "call_result") (LConstE (LInt 0)))
                ] (CondBr (?^ "cond") (?^ "success_block") (?^ "failure_block")),
                
                MkBasicBlock "success_block" [
                ] (Ret (LInt 32) (LConstE (LInt 0))),
                
                MkBasicBlock "failure_block" [
                ] (Ret (LInt 32) (LConstE (LInt 1)))
            ],
            tags = []
        },
        -- Helper function
        FunctionDefC $ MkFunctionDef {
            name = "helper_function",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkArgument (LInt 32) [] (Just "a"),
                MkArgument (LInt 32) [] (Just "b")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBasicBlock "entry" [
                    -- Perform various operations
                    "sum" $<- (Add (LInt 32) (?^ "a") (?^ "b")),
                    "diff" $<- (Sub (LInt 32) (?^ "a") (?^ "b")),
                    "product" $<- (Mul (LInt 32) (?^ "sum") (?^ "diff")),
                    -- Use aggregate operation
                    "array_val" $<- ((ExtractValue (MkWithType (LArray 5 (LInt 32)) (LConstE (LPtr (Global "data_array")))) 0)),
                    "final_result" $<- (Add (LInt 32) (?^ "product") (?^ "array_val"))
                ] (Ret (LInt 32) (?^ "final_result"))
            ],
            tags = []
        },
    
        -- External function declaration
        FunctionDecC $ MkFunctionDec {
            name = "printf",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkArgument LPtr [] Nothing],
            addressInfo = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            tags = []
        }
    ],
    tags = Nothing
}

export
-- Module with thread-local storage and address spaces
moduleWithTLS : LModule
moduleWithTLS = MkLModule {
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        -- Thread-local variable
        GlobalDefC $ MkGVarDef {
            name = "tls_counter",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Just LocalDynamic,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LInt 32,
            initializer = Just (LInt 0),
            tags = []
        },
        -- Global in specific address space
        GlobalDefC $ MkGVarDef {
            name = "gpu_memory",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Just (UnnamedSpace 1),
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LArray 1024 (LInt 8),
            initializer = Nothing,
            tags = []
        }
    ],
    tags = Nothing
}
export
-- Module with various calling conventions
moduleWithCallingConventions : LModule
moduleWithCallingConventions = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Error format string
        GlobalDefC $ MkGVarDef {
            name = "error_format",
            symbolInfo = MkSymbolInfo (Just Private) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LArray 15 (LInt 8),
            initializer = Just (LString "Error: %d\\0a\\00"),
            tags = []
        },
        -- Fast calling convention function
        FunctionDefC $ MkFunctionDef {
            name = "fast_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just Fast,
            returnAttrs = [],
            returnType = LFloating LFloat,
            args = [
                MkArgument (LFloating LFloat) [] (Just "x"),
                MkArgument (LFloating LFloat) [] (Just "y")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBasicBlock "entry" [
                    "result" $<- ((FAdd []) (LFloating LFloat) (?^ "x") (?^ "y"))
                ] (Ret (LFloating LFloat) (?^ "result"))
            ],
            tags = []
        },
        -- Cold calling convention function (rarely called)
        FunctionDefC $ MkFunctionDef {
            name = "error_handler",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            callingConvention = Just Cold,
            returnAttrs = [],
            returnType = LVoid,
            args = [MkArgument (LInt 32) [] (Just "error_code")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBasicBlock "entry" [
                    -- Call printf to report error
                    "printf_result" $<- ((FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                        (LFun (LInt 32) [LPtr]) 
                        (LConstE (LPtr (Global "printf"))) 
                        [MkWithType LPtr (LConstE (LPtr (Global "error_format")))] [])))
                ] RetVoid
            ],
            tags = []
        }
    ],
    tags = Nothing
}

export
-- Module with vector operations
moduleWithVectors : LModule
moduleWithVectors = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "vector_operations",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LVector 4 (LInt 32),
            args = [
                MkArgument (LVector 4 (LInt 32)) [] (Just "vec1"),
                MkArgument (LVector 4 (LInt 32)) [] (Just "vec2")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBasicBlock "entry" [
                    -- Extract element from first vector
                    "elem1" $<- ((ExtractElement 
                        ( ( 4 :<> (:# 32)) <:> (?^ "vec1"))
                        ( (:# 32) <:> (LConstE (LInt 0))))),
                    -- Insert element into second vector
                    "modified_vec" $<- ((InsertElement 
                        ( ( 4 :<> (LInt 32)) <:> (?^ "vec2"))
                        ( (LInt 32) <:> (?^ "elem1"))
                        ( (LInt 32) <:> (LConstE (LInt 1))))),
                    -- Shuffle vectors
                    "shuffled" $<- ((ShuffleVector
                        ( ( 4 :<> (LInt 32)) <:> (?^ "vec1"))
                        ( ( 4 :<> (LInt 32)) <:> (?^ "modified_vec"))
                        ( ( 4 :<> (LInt 32)) <:> (LConstE (LVector [
                             (:# 32) <:> (LInt 0),
                             (:# 32) <:> (LInt 5),
                             (:# 32) <:> (LInt 2),
                             (:# 32) <:> (LInt 7)
                        ])))))
                ] (Ret (LVector 4 (LInt 32)) (?^ "shuffled"))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

export
-- Module with control flow and phi nodes
moduleWithControlFlow : LModule
moduleWithControlFlow = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "fibonacci",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkArgument (LInt 32) [] (Just "n")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBasicBlock "entry" [
                    -- Check if n <= 1 (use proper comparison)
                    "cmp" $<- (icmp CSLe (LInt 32) (?^ "n") (LConstE (LInt 1)))
                ] (CondBr (?^ "cmp") (?^ "base_case") (?^ "recursive_case")),
                
                MkBasicBlock "base_case" [
                ] (Ret (LInt 32) (?^ "n")),
                
                MkBasicBlock "recursive_case" [
                    -- Calculate fib(n-1)
                    "n_minus_1" $<- (Sub (LInt 32) (?^ "n") (LConstE (LInt 1))),
                    "fib_n_minus_1" $<- ((FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                        (LFun (LInt 32) [LInt 32]) 
                        (LConstE (LPtr (Global "fibonacci"))) 
                        [MkWithType (LInt 32) (?^ "n_minus_1")] []))),
                    -- Calculate fib(n-2)
                    "n_minus_2" $<- (Sub (LInt 32) (?^ "n") (LConstE (LInt 2))),
                    "fib_n_minus_2" $<- ((FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                        (LFun (LInt 32) [LInt 32]) 
                        (LConstE (LPtr (Global "fibonacci"))) 
                        [MkWithType (LInt 32) (?^ "n_minus_2")] []))),
                    -- Add results
                    "result" $<- (Add (LInt 32) (?^ "fib_n_minus_1") (?^ "fib_n_minus_2"))
                ] (Ret (LInt 32) (?^ "result"))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

export
-- Module with switch statements and multiple cases
moduleWithSwitch : LModule
moduleWithSwitch = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "handle_opcode",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkArgument (LInt 32) [] (Just "opcode")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBasicBlock "entry" [
                ] (Switch (LInt 32) (?^ "opcode") (Local "default") [
                    MkCaseBranch (LInt 32) (LConstE (LInt 1)) (?^ "case_add"),
                    MkCaseBranch (LInt 32) (LConstE (LInt 2)) (?^ "case_sub"),
                    MkCaseBranch (LInt 32) (LConstE (LInt 3)) (?^ "case_mul"),
                    MkCaseBranch (LInt 32) (LConstE (LInt 4)) (?^ "case_div")
                ]),
                
                MkBasicBlock "case_add" [
                ] (Ret (LInt 32) (LConstE (LInt 100))),
                
                MkBasicBlock "case_sub" [
                ] (Ret (LInt 32) (LConstE (LInt 200))),
                
                MkBasicBlock "case_mul" [
                ] (Ret (LInt 32) (LConstE (LInt 300))),
                
                MkBasicBlock "case_div" [
                ] (Ret (LInt 32) (LConstE (LInt 400))),
                
                MkBasicBlock "default" [
                ] (Ret (LInt 32) (LConstE (LInt (-1))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}
{- 
-- Module with struct operations and complex types
moduleWithStructs : LModule
moduleWithStructs = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Global struct
        GlobalDefC $ MkGVarDef {
            name = "global_point",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LStruct [LInt 32, LInt 32],
            initializer = Just (LStruct [MkWithType (LInt 32) (LInt 10), MkWithType (LInt 32) (LInt 20)]),
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "struct_operations",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkArgument (LStruct [LInt 32, LInt 32]) [] (Just "point")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBasicBlock "entry" [
                -- Extract x coordinate
                MkLStatement (Local "x") ((ExtractValue 
                    (MkWithType (LStruct [LInt 32, LInt 32]) (LConstE (LPtr (Local "point")))) 0)),
                -- Extract y coordinate
                MkLStatement (Local "y") ((ExtractValue 
                    (MkWithType (LStruct [LInt 32, LInt 32]) (LConstE (LPtr (Local "point")))) 1)),
                -- Calculate sum
                MkLStatement (Local "sum") (Add (LInt 32) (LConstE (LPtr (Local "x"))) (LConstE (LPtr (Local "y")))),
                -- Create new struct with modified values
                MkLStatement (Local "new_point") ((InsertValue 
                    (MkWithType (LStruct [LInt 32, LInt 32]) (LConstE (LPtr (Local "point"))))
                    (MkWithType (LInt 32) (LConstE (LPtr (Local "sum"))))
                    0))
            ] (Ret (LInt 32) (LConstE (LPtr (Local "sum")))))],
            tags = []
        }
    ],
    tags = Nothing
}
-}
-- Module with aliases and IFuncs
export
moduleWithAliases : LModule
moduleWithAliases = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Function to be aliased
        FunctionDefC $ MkFunctionDef {
            name = "original_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkArgument (LInt 32) [] (Just "x")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBasicBlock "entry" [
                "result" $<- (Mul (LInt 32) (?^ "x") (LConstE (LInt 2)))
            ] (Ret (LInt 32) (?^ "result"))],
            tags = []
        },
        -- Alias to the function
        AliasC $ MkAlias {
            name = "function_alias",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            aliasTpe = LFun (LInt 32) [LInt 32],
            aliasee = "original_function",
            tags = []
        },
        -- IFunc with resolver
        IFuncC $ MkIFunc {
            name = "dynamic_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            funTpe = LFun (LInt 32) [LInt 32],
            resTpe = LPtr,
            resolver = "function_resolver",
            tags = []
        }
    ],
    tags = Nothing
}

{- 
export
-- Module with exception handling and personality functions
moduleWithExceptions : LModule
moduleWithExceptions = MkLModule {
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        -- Declare exception handling personality function
        FunctionDecC $ MkFunctionDec {
            name = "__gxx_personality_v0",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkArgument (LInt 32) [] Nothing, MkArgument (LInt 32) [] Nothing, MkArgument (LInt 64) [] Nothing, MkArgument LPtr [] Nothing, MkArgument LPtr [] Nothing],
            addressInfo = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "exception_test",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkArgument (LInt 32) [] (Just "x")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Just (LPtr (Global "__gxx_personality_v0")),
            metadata = [],
            body = [
                MkBasicBlock "entry" [
                    -- Invoke that might throw
                    "result" $<- (id (Invoke (MkInvokeCall (Just C) [] Nothing 
                        (LFun (LInt 32) [LInt 32]) 
                        (LConstE (LPtr (Global "might_throw"))) 
                        [?^ "x"]
                        (?^ "normal")
                        (?^ "exception"))))
                ] (JumpBr (?^ "normal")),
                
                MkBasicBlock "normal" [
                ] (Ret (LInt 32) (?^ "result")),
                
                MkBasicBlock "exception" [
                    -- Landing pad for exception handling (simplified for demo)
                    "landing_pad" $<- (Add (LInt 32) (LConstE (LInt 0)) (LConstE (LInt 0)))
                ] (Ret (LInt 32) (LConstE (LInt (-1))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}
-}
export
-- Module with atomic operations and memory ordering
moduleWithAtomics : LModule
moduleWithAtomics = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Global atomic counter
        GlobalDefC $ MkGVarDef {
            name = "atomic_counter",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LInt 32,
            initializer = Just (LInt 0),
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "atomic_operations",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkArgument (LInt 32) [] (Just "value")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBasicBlock "entry" [
                -- Simple memory operations using variants
                "old_value" $<- ((LoadRegular False (LInt 32)
                    (LConstE (LPtr (Global "atomic_counter")))
                    Nothing False False False False Nothing Nothing Nothing False)),
                -- Store atomic value
                $<< ((StoreRegular False
                    (MkWithType (LInt 32) (?^ "value"))
                    (LConstE (LPtr (Global "atomic_counter")))
                    Nothing False False))
                -- Memory fence
            ] (Ret (LInt 32) (?^ "old_value"))],
            tags = []
        }
    ],
    tags = Nothing
}


export
-- Module with inline assembly
moduleWithInlineAssembly : LModule
moduleWithInlineAssembly = MkLModule {
    dataLayout = Nothing,
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "inline_asm_test",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkArgument (LInt 32) [] (Just "a"),
                MkArgument (LInt 32) [] (Just "b")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBasicBlock "entry" [
                -- Inline assembly to add two numbers (simplified for demo)
                "result" $<- (Add (LInt 32) (?^ "a") (?^ "b"))
            ] (Ret (LInt 32) (?^ "result"))],
            tags = []
        }
    ],
    tags = Nothing
}

export
-- Module with debug information and metadata
moduleWithDebugInfo : LModule
moduleWithDebugInfo = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "debug_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkArgument (LInt 32) [] (Just "param")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBasicBlock "entry" [
                -- Allocate local variable
                "local_var_ptr" $<- ((Alloc (LInt 32) Nothing Nothing Nothing)),
                -- Calculate the value
                "local_var" $<- (Add (LInt 32) (?^ "param") (LConstE (LInt 1))),
                -- Store the value
                $<< ((StoreRegular False 
                    (MkWithType (LInt 32) (?^ "local_var"))
                    (?^ "local_var_ptr")
                    Nothing False False)),
                -- Call debug intrinsic with pointer
                $<< ((FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun LVoid [LPtr, LPtr, LPtr]) 
                    (LConstE (LPtr (Global "llvm.dbg.declare"))) 
                    [
                        MkWithType LPtr (?^ "local_var_ptr"),
                        MkWithType LPtr (LConstE LNull),
                        MkWithType LPtr (LConstE LNull)
                    ] [])))
            ] (Ret (LInt 32) (?^ "local_var"))],
            tags = []
        }
    ],
    tags = Nothing
}

export
-- Module with complex nested structures and packed types
moduleWithComplexTypes : LModule
moduleWithComplexTypes = MkLModule {
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Nothing,
    text = [
        -- Complex nested struct type
        GlobalDefC $ MkGVarDef {
            name = "complex_struct",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LStruct [
                LInt 8,  -- flags
                LPackedStruct [LInt 16, LInt 16],  -- packed coordinates
                LArray 10 (LFloating LDouble),    -- array of doubles
                LStruct [                         -- nested struct
                    LPtr,                         -- pointer
                    LVector 4 (LInt 32),         -- vector
                    LFun LVoid [LInt 32]         -- function pointer
                ]
            ],
            initializer = Nothing,
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "process_complex_type",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LVoid,
            args = [MkArgument LPtr [] (Just "complex_ptr")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBasicBlock "entry" [
                -- Get element pointer using a simpler approach
                "nested_ptr" $<- ((ExtractValue
                    (MkWithType (LStruct [
                        LInt 8,  -- flags
                        LPackedStruct [LInt 16, LInt 16],  -- packed coordinates
                        LArray 10 (LFloating LDouble),    -- array of doubles
                        LStruct [                         -- nested struct
                            LPtr,                         -- pointer
                            LVector 4 (LInt 32),         -- vector
                            LFun LVoid [LInt 32]         -- function pointer
                        ]
                    ]) (?^ "complex_ptr")) 3)),
                -- Extract vector from nested struct
                "vector_ptr" $<- ((ExtractValue
                    (MkWithType (LStruct [LPtr, LVector 4 (LInt 32), LFun LVoid [LInt 32]]) 
                     (?^ "nested_ptr")) 1)),
                -- Load the vector using simple load
                "vector" $<- ((LoadRegular False (LVector 4 (LInt 32))
                    (?^ "vector_ptr")
                    Nothing False False False False Nothing Nothing Nothing False))
            ] RetVoid],
            tags = []
        }
    ],
    tags = Nothing
}

