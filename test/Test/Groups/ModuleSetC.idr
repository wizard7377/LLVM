-- NOTE: A large portion of this file was generated by AI
-- TODO: Finish converting to builder / op api
module Test.Groups.ModuleSetC


import Data.LLVM
import Data.LLVM.IR
import Data.LLVM.Write.Text.Encode
import Data.LLVM.Class
import Data.LLVM.Ops.Math
import Test.Helper
import Data.LLVM.Write.Foreign
import Data.LLVM.Ops.Sugar
import Data.Table
export
-- Module with switch statements and multiple cases
moduleWithSwitch : LModule
moduleWithSwitch = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "handle_opcode",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkArgument (:# 32) [] (Just "opcode")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkPair "entry" $ MkBasicBlock [
                ] (Switch (:# 32) (?^ "opcode") (#^ "default") [
                    MkCaseBranch (:# 32) (## 1) (#^ "case_add"),
                    MkCaseBranch (:# 32) (## 2) (#^ "case_sub"),
                    MkCaseBranch (:# 32) (## 3) (#^ "case_mul"),
                    MkCaseBranch (:# 32) (## 4) (#^ "case_div")
                ]),
                
                MkPair "case_add" $ MkBasicBlock [
                ] (Ret (:# 32) (## 100)),
                
                MkPair "case_sub" $ MkBasicBlock [
                ] (Ret (:# 32) (## 200)),
                
                MkPair "case_mul" $ MkBasicBlock [
                ] (Ret (:# 32) (## 300)),
                
                MkPair "case_div" $ MkBasicBlock [
                ] (Ret (:# 32) (## 400)),
                
                MkPair "default" $ MkBasicBlock [
                ] (Ret (:# 32) (## -1))
            ],
            tags = neutral
        }
    ],
    tags = neutral
}

-- TODO: (Add NoWrap) to tests
export
-- Module with switch statements and multiple cases
moduleWithSwitchLifted : LModule
moduleWithSwitchLifted = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "handle_opcode",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkArgument (:# 32) [] (Just "opcode")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkPair "entry" $ MkBasicBlock [
                ] (Switch (:# 32) (?^ "opcode") (!# ([] !> (Ret (:# 32) (## -1)))) [
                    MkCaseBranch (:# 32) (## 1) (!# ([] !> (Ret (:# 32) (## 100)))),
                    MkCaseBranch (:# 32) (## 2) (!# ([] !> (Ret (:# 32) (## 200)))),
                    MkCaseBranch (:# 32) (## 3) (!# ([] !> (Ret (:# 32) (## 300)))),
                    MkCaseBranch (:# 32) (## 4) (!# ([] !> (Ret (:# 32) (## 400))))
                ])
            ],
            tags = neutral
        }
    ],
    tags = neutral
}
{- 
-- Module with struct operations and complex types
moduleWithStructs : LModule
moduleWithStructs = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Global struct
        GlobalDefC $ MkGVarDef {
            name = "global_point",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LStruct [LInt 32, LInt 32],
            initializer = Just (LStruct [MkWithType (:# 32) (LInt 10), MkWithType (:# 32) (LInt 20)]),
            tags = neutral
        },
        FunctionDefC $ MkFunctionDef {
            name = "struct_operations",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkArgument (LStruct [LInt 32, LInt 32]) [] (Just "point")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkPair "entry" $ MkBasicBlock [
                -- Extract x coordinate
                MkLStatement (Local "x") ((ExtractValue 
                    (MkWithType (LStruct [LInt 32, LInt 32]) (id (LPtr (Local "point")))) 0)),
                -- Extract y coordinate
                MkLStatement (Local "y") ((ExtractValue 
                    (MkWithType (LStruct [LInt 32, LInt 32]) (id (LPtr (Local "point")))) 1)),
                -- Calculate sum
                MkLStatement (Local "sum") ((Add NoWrap) (:# 32) (id (LPtr (Local "x"))) (id (LPtr (Local "y")))),
                -- Create new struct with modified values
                MkLStatement (Local "new_point") ((InsertValue 
                    (MkWithType (LStruct [LInt 32, LInt 32]) (id (LPtr (Local "point"))))
                    (MkWithType (:# 32) (id (LPtr (Local "sum"))))
                    0))
            ] (Ret (:# 32) (id (LPtr (Local "sum")))))],
            tags = neutral
        }
    ],
    tags = neutral
}
-}
-- Module with aliases and IFuncs
export
moduleWithAliases : LModule
moduleWithAliases = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Function to be aliased
        FunctionDefC $ MkFunctionDef {
            name = "original_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkArgument (:# 32) [] (Just "x")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkPair "entry" $ MkBasicBlock [
                "result" <<- ((Mul NoWrap) (:# 32) (?^ "x") (## 2))
            ] (Ret (:# 32) (?^ "result"))],
            tags = neutral
        },
        -- Alias to the function
        AliasC $ MkAlias {
            name = "function_alias",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            aliasTpe = LFun (:# 32) [LInt 32],
            aliasee = "original_function",
            tags = neutral
        },
        -- IFunc with resolver
        IFuncC $ MkIFunc {
            name = "dynamic_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            funTpe = LFun (:# 32) [LInt 32],
            resTpe = LPtr,
            resolver = "function_resolver",
            tags = neutral
        }
    ],
    tags = neutral
}

{- 
export
-- Module with exception handling and personality functions
moduleWithExceptions : LModule
moduleWithExceptions = MkLModule {
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        -- Declare exception handling personality function
        FunctionDecC $ MkFunctionDec {
            name = "__gxx_personality_v0",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkArgument (:# 32) [] Nothing, MkArgument (:# 32) [] Nothing, MkArgument (LInt 64) [] Nothing, MkArgument LPtr [] Nothing, MkArgument LPtr [] Nothing],
            addressInfo = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            tags = neutral
        },
        FunctionDefC $ MkFunctionDef {
            name = "exception_test",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkArgument (:# 32) [] (Just "x")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Just (LVar (Global "__gxx_personality_v0")),
            metadata = [],
            body = [
                MkPair "entry" $ MkBasicBlock [
                    -- Invoke that might throw
                    "result" <<- (id (Invoke (MkInvokeCall (Just C) [] Nothing 
                        (LFun (:# 32) [LInt 32]) 
                        (id (LVar (Global "might_throw"))) 
                        [?^ "x"]
                        (?^ "normal")
                        (?^ "exception"))))
                ] (JumpBr (?^ "normal")),
                
                MkPair "normal" $ MkBasicBlock [
                ] (Ret (:# 32) (?^ "result")),
                
                MkPair "exception" $ MkBasicBlock [
                    -- Landing pad for exception handling (simplified for demo)
                    "landing_pad" <<- ((Add NoWrap) (:# 32) (## 0) (## 0))
                ] (Ret (:# 32) (id (LInt (-1))))
            ],
            tags = neutral
        }
    ],
    tags = neutral
}
-}
export
-- Module with atomic operations and memory ordering
moduleWithAtomics : LModule
moduleWithAtomics = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Global atomic counter
        GlobalDefC $ MkGVarDef {
            name = "atomic_counter",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LInt 32,
            initializer = Just (LInt 0),
            tags = neutral
        },
        FunctionDefC $ MkFunctionDef {
            name = "atomic_operations",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkArgument (:# 32) [] (Just "value")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkPair "entry" $ MkBasicBlock [
                -- Simple memory operations using variants
                "old_value" <<- ((Load False (:# 32)
                    (id (LVar (Global "atomic_counter")))
                    Nothing False False False False Nothing Nothing Nothing False)),
                -- Store atomic value
                -<< ((StoreRegular False
                    (MkWithType (:# 32) (?^ "value"))
                    (id (LVar (Global "atomic_counter")))
                    Nothing False False))
                -- Memory fence
            ] (Ret (:# 32) (?^ "old_value"))],
            tags = neutral
        }
    ],
    tags = neutral
}


export
-- Module with inline assembly
moduleWithInlineAssembly : LModule
moduleWithInlineAssembly = MkLModule {
    dataLayout = Nothing,
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "inline_asm_test",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkArgument (:# 32) [] (Just "a"),
                MkArgument (:# 32) [] (Just "b")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkPair "entry" $ MkBasicBlock [
                -- Inline assembly to add two numbers (simplified for demo)
                "result" <<- ((Add NoWrap) (:# 32) (?^ "a") (?^ "b"))
            ] (Ret (:# 32) (?^ "result"))],
            tags = neutral
        }
    ],
    tags = neutral
}

export
-- Module with debug information and metadata
moduleWithDebugInfo : LModule
moduleWithDebugInfo = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "debug_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkArgument (:# 32) [] (Just "param")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkPair "entry" $ MkBasicBlock [
                -- Allocate local variable
                "local_var_ptr" <<- ((Alloc (:# 32) Nothing Nothing Nothing)),
                -- Calculate the value
                "local_var" <<- ((Add NoWrap) (:# 32) (?^ "param") (## 1)),
                -- Store the value
                -<< ((StoreRegular False 
                    (MkWithType (:# 32) (?^ "local_var"))
                    (?^ "local_var_ptr")
                    Nothing False False)),
                -- Call debug intrinsic with pointer
                -<< ((FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun LVoid [LPtr, LPtr, LPtr]) 
                    (id (LVar (Global "llvm.dbg.declare"))) 
                    [
                        (?^ "local_var_ptr") <:> LPtr,
                        mkNull <:> LPtr,
                        mkNull <:> LPtr
                    ] [])))
            ] (Ret (:# 32) (?^ "local_var"))],
            tags = neutral
        }
    ],
    tags = neutral
}

export
-- Module with complex nested structures and packed types
moduleWithComplexTypes : LModule
moduleWithComplexTypes = MkLModule {
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Nothing,
    text = [
        -- Complex nested struct type
        GlobalDefC $ MkGVarDef {
            name = "complex_struct",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LStruct [
                LInt 8,  -- flags
                LPackedStruct [LInt 16, LInt 16],  -- packed coordinates
                LArray 10 (LFloating LDouble),    -- array of doubles
                LStruct [                         -- nested struct
                    LPtr,                         -- pointer
                    LVector 4 (:# 32),         -- vector
                    LFun LVoid [LInt 32]         -- function pointer
                ]
            ],
            initializer = Nothing,
            tags = neutral
        },
        FunctionDefC $ MkFunctionDef {
            name = "process_complex_type",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LVoid,
            args = [MkArgument LPtr [] (Just "complex_ptr")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkPair "entry" $ MkBasicBlock [
                -- Get element pointer using a simpler approach
                "nested_ptr" <<- ((ExtractValue
                    (MkWithType (LStruct [
                        LInt 8,  -- flags
                        LPackedStruct [LInt 16, LInt 16],  -- packed coordinates
                        LArray 10 (LFloating LDouble),    -- array of doubles
                        LStruct [                         -- nested struct
                            LPtr,                         -- pointer
                            LVector 4 (:# 32),         -- vector
                            LFun LVoid [LInt 32]         -- function pointer
                        ]
                    ]) (?^ "complex_ptr")) 3)),
                -- Extract vector from nested struct
                "vector_ptr" <<- ((ExtractValue
                    (MkWithType (LStruct [LPtr, LVector 4 (:# 32), LFun LVoid [LInt 32]]) 
                     (?^ "nested_ptr")) 1)),
                -- Load the vector using simple load
                "vector" <<- ((Load False (LVector 4 (:# 32))
                    (?^ "vector_ptr")
                    Nothing False False False False Nothing Nothing Nothing False))
            ] RetVoid],
            tags = neutral
        }
    ],
    tags = neutral
}

