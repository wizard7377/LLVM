-- NOTE: A large portion of this file was generated by AI

module Test.Groups.Module

import Data.LLVM
import Data.LLVM.IR
import Data.LLVM.Write.Assembly
import Data.LLVM.Class
import Data.LLVM.IR.Builders.Math
import Test.Helper


-- Helper functions to create test modules

emptyModule : LModule
emptyModule = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [],
    tags = Nothing
}

moduleWithGlobals : LModule
moduleWithGlobals = MkLModule {
    
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        -- Global integer variable
        GlobalDefC $ MkGVarDef {
            name = "global_counter",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = True,
            gtpe = LInt 32,
            initializer = Just (LInt 42),
            tags = []
        },
        -- Global constant string
        GlobalDefC $ MkGVarDef {
            name = "hello_string",
            symbolInfo = MkSymbolInfo (Just Private) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = True,
            gtpe = LArray 13 (LInt 8),
            initializer = Just (LString "Hello, World!\\00"),
            tags = []
        }
    ],
    tags = Nothing
}

moduleWithSimpleFunction : LModule
moduleWithSimpleFunction = MkLModule {
    
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "simple_add",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkFunctionArgSpec (LInt 32) [] (Just "a"),
                MkFunctionArgSpec (LInt 32) [] (Just "b")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBlock (Just "entry") [
                    Operation (Local "result") (BinaryOp Add (LInt 32) (LVar (Local "a")) (LVar (Local "b")))
                ] (Ret (LInt 32) (LVar (Local "result")))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

moduleWithOperations : LModule
moduleWithOperations = MkLModule {
    
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "main",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkFunctionArgSpec (LInt 32) [] (Just "x"),
                MkFunctionArgSpec (LInt 32) [] (Just "y")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBlock (Just "entry") [
                    -- Multiply x and y
                    Operation (Local "mul_result") (BinaryOp Mul (LInt 32) (LVar (Local "x")) (LVar (Local "y"))),
                    -- Add 10 to the result
                    Operation (Local "add_result") (BinaryOp Add (LInt 32) (LVar (Local "mul_result")) (LConstE (LInt 10))),
                    -- Shift left by 1
                    Operation (Local "shift_result") (BinaryOp Shl (LInt 32) (LVar (Local "add_result")) (LConstE (LInt 1)))
                ] (Ret (LInt 32) (LVar (Local "shift_result")))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

completeModule : LModule
completeModule = MkLModule {
    
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        -- Global array
        GlobalDefC $ MkGVarDef {
            name = "data_array",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = True,
            gtpe = LArray 5 (LInt 32),
            initializer = Just (LArray [MkWithType (LInt 32) (LInt 1), MkWithType (LInt 32) (LInt 2), MkWithType (LInt 32) (LInt 3), MkWithType (LInt 32) (LInt 4), MkWithType (LInt 32) (LInt 5)]),
            tags = []
        },
        -- Main function
        FunctionDefC $ MkFunctionDef {
            name = "main",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkFunctionArgSpec (LInt 32) [] (Just "argc"),
                MkFunctionArgSpec LPtr [] (Just "argv")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBlock (Just "entry") [
                    -- Allocate local variable
                    Operation (Local "local_var") (MemoryOp (Alloc (LInt 32) Nothing Nothing Nothing)),
                    -- Call helper function
                    Operation (Local "call_result") (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing (LFun (LInt 32) [LInt 32, LInt 32]) (LConstE (LPtr (Global "helper_function"))) [MkWithType (LInt 32) (LConstE (LInt 5)), MkWithType (LInt 32) (LConstE (LInt 10))] []))),
                    -- Compare i32 result with 0 to produce i1 for conditional branch
                    Operation (Local "cond") (icmp CEq (LInt 32) (LVar (Local "call_result")) (LConstE (LInt 0)))
                ] (CondBr (LVar (Local "cond")) (LVar (Local "success_block")) (LVar (Local "failure_block"))),
                
                MkBlock (Just "success_block") [
                ] (Ret (LInt 32) (LConstE (LInt 0))),
                
                MkBlock (Just "failure_block") [
                ] (Ret (LInt 32) (LConstE (LInt 1)))
            ],
            tags = []
        },
        -- Helper function
        FunctionDefC $ MkFunctionDef {
            name = "helper_function",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkFunctionArgSpec (LInt 32) [] (Just "a"),
                MkFunctionArgSpec (LInt 32) [] (Just "b")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBlock (Just "entry") [
                    -- Perform various operations
                    Operation (Local "sum") (BinaryOp Add (LInt 32) (LVar (Local "a")) (LVar (Local "b"))),
                    Operation (Local "diff") (BinaryOp Sub (LInt 32) (LVar (Local "a")) (LVar (Local "b"))),
                    Operation (Local "product") (BinaryOp Mul (LInt 32) (LVar (Local "sum")) (LVar (Local "diff"))),
                    -- Use aggregate operation
                    Operation (Local "array_val") (AggregateOp (ExtractValue (MkWithType (LArray 5 (LInt 32)) (LConstE (LPtr (Global "data_array")))) 0)),
                    Operation (Local "final_result") (BinaryOp Add (LInt 32) (LVar (Local "product")) (LVar (Local "array_val")))
                ] (Ret (LInt 32) (LVar (Local "final_result")))
            ],
            tags = []
        },
    
        -- External function declaration
        FunctionDecC $ MkFunctionDec {
            name = "printf",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec LPtr [] Nothing],
            addressInfo = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with thread-local storage and address spaces
moduleWithTLS : LModule
moduleWithTLS = MkLModule {
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        -- Thread-local variable
        GlobalDefC $ MkGVarDef {
            name = "tls_counter",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Just LocalDynamic,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LInt 32,
            initializer = Just (LInt 0),
            tags = []
        },
        -- Global in specific address space
        GlobalDefC $ MkGVarDef {
            name = "gpu_memory",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Just (UnnamedSpace 1),
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LArray 1024 (LInt 8),
            initializer = Nothing,
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with various calling conventions
moduleWithCallingConventions : LModule
moduleWithCallingConventions = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Error format string
        GlobalDefC $ MkGVarDef {
            name = "error_format",
            symbolInfo = MkSymbolInfo (Just Private) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LArray 15 (LInt 8),
            initializer = Just (LString "Error: %d\\0a\\00"),
            tags = []
        },
        -- Fast calling convention function
        FunctionDefC $ MkFunctionDef {
            name = "fast_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just Fast,
            returnAttrs = [],
            returnType = LFloating LFloat,
            args = [
                MkFunctionArgSpec (LFloating LFloat) [] (Just "x"),
                MkFunctionArgSpec (LFloating LFloat) [] (Just "y")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBlock (Just "entry") [
                    Operation (Local "result") (BinaryOp (FAdd []) (LFloating LFloat) (LConstE (LPtr (Local "x"))) (LConstE (LPtr (Local "y"))))
                ] (Ret (LFloating LFloat) (LConstE (LPtr (Local "result"))))
            ],
            tags = []
        },
        -- Cold calling convention function (rarely called)
        FunctionDefC $ MkFunctionDef {
            name = "error_handler",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            callingConvention = Just Cold,
            returnAttrs = [],
            returnType = LVoid,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "error_code")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBlock (Just "entry") [
                    -- Call printf to report error
                    Operation (Local "printf_result") (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                        (LFun (LInt 32) [LPtr]) 
                        (LConstE (LPtr (Global "printf"))) 
                        [MkWithType LPtr (LConstE (LPtr (Global "error_format")))] [])))
                ] RetVoid
            ],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with vector operations
moduleWithVectors : LModule
moduleWithVectors = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "vector_operations",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LVector 4 (LInt 32),
            args = [
                MkFunctionArgSpec (LVector 4 (LInt 32)) [] (Just "vec1"),
                MkFunctionArgSpec (LVector 4 (LInt 32)) [] (Just "vec2")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBlock (Just "entry") [
                    -- Extract element from first vector
                    Operation (Local "elem1") (VectorOp (ExtractElement 
                        (MkWithType (LVector 4 (LInt 32)) (LConstE (LPtr (Local "vec1"))))
                        (MkWithType (LInt 32) (LConstE (LInt 0))))),
                    -- Insert element into second vector
                    Operation (Local "modified_vec") (VectorOp (InsertElement 
                        (MkWithType (LVector 4 (LInt 32)) (LConstE (LPtr (Local "vec2"))))
                        (MkWithType (LInt 32) (LConstE (LPtr (Local "elem1"))))
                        (MkWithType (LInt 32) (LConstE (LInt 1))))),
                    -- Shuffle vectors
                    Operation (Local "shuffled") (VectorOp (ShuffleVector
                        (MkWithType (LVector 4 (LInt 32)) (LConstE (LPtr (Local "vec1"))))
                        (MkWithType (LVector 4 (LInt 32)) (LConstE (LPtr (Local "modified_vec"))))
                        (MkWithType (LVector 4 (LInt 32)) (LConstE (LVector [
                            MkWithType (LInt 32) (LInt 0),
                            MkWithType (LInt 32) (LInt 5),
                            MkWithType (LInt 32) (LInt 2),
                            MkWithType (LInt 32) (LInt 7)
                        ])))))
                ] (Ret (LVector 4 (LInt 32)) (LConstE (LPtr (Local "shuffled"))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with control flow and phi nodes
moduleWithControlFlow : LModule
moduleWithControlFlow = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "fibonacci",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "n")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBlock (Just "entry") [
                    -- Check if n <= 1 (use proper comparison)
                    Operation (Local "cmp") (icmp CSLe (LInt 32) (LVar (Local "n")) (LConstE (LInt 1)))
                ] (CondBr (LVar (Local "cmp")) (LVar (Local "base_case")) (LVar (Local "recursive_case"))),
                
                MkBlock (Just "base_case") [
                ] (Ret (LInt 32) (LVar (Local "n"))),
                
                MkBlock (Just "recursive_case") [
                    -- Calculate fib(n-1)
                    Operation (Local "n_minus_1") (BinaryOp Sub (LInt 32) (LVar (Local "n")) (LConstE (LInt 1))),
                    Operation (Local "fib_n_minus_1") (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                        (LFun (LInt 32) [LInt 32]) 
                        (LConstE (LPtr (Global "fibonacci"))) 
                        [MkWithType (LInt 32) (LVar (Local "n_minus_1"))] []))),
                    -- Calculate fib(n-2)
                    Operation (Local "n_minus_2") (BinaryOp Sub (LInt 32) (LVar (Local "n")) (LConstE (LInt 2))),
                    Operation (Local "fib_n_minus_2") (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                        (LFun (LInt 32) [LInt 32]) 
                        (LConstE (LPtr (Global "fibonacci"))) 
                        [MkWithType (LInt 32) (LVar (Local "n_minus_2"))] []))),
                    -- Add results
                    Operation (Local "result") (BinaryOp Add (LInt 32) (LVar (Local "fib_n_minus_1")) (LVar (Local "fib_n_minus_2")))
                ] (Ret (LInt 32) (LVar (Local "result")))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with switch statements and multiple cases
moduleWithSwitch : LModule
moduleWithSwitch = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "handle_opcode",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "opcode")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [
                MkBlock (Just "entry") [
                ] (Switch (LInt 32) (LVar (Local "opcode")) (Local "default") [
                    MkCaseBranch (LInt 32) (LConstE (LInt 1)) (LVar (Local "case_add")),
                    MkCaseBranch (LInt 32) (LConstE (LInt 2)) (LVar (Local "case_sub")),
                    MkCaseBranch (LInt 32) (LConstE (LInt 3)) (LVar (Local "case_mul")),
                    MkCaseBranch (LInt 32) (LConstE (LInt 4)) (LVar (Local "case_div"))
                ]),
                
                MkBlock (Just "case_add") [
                ] (Ret (LInt 32) (LConstE (LInt 100))),
                
                MkBlock (Just "case_sub") [
                ] (Ret (LInt 32) (LConstE (LInt 200))),
                
                MkBlock (Just "case_mul") [
                ] (Ret (LInt 32) (LConstE (LInt 300))),
                
                MkBlock (Just "case_div") [
                ] (Ret (LInt 32) (LConstE (LInt 400))),
                
                MkBlock (Just "default") [
                ] (Ret (LInt 32) (LConstE (LInt (-1))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with struct operations and complex types
moduleWithStructs : LModule
moduleWithStructs = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Global struct
        GlobalDefC $ MkGVarDef {
            name = "global_point",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LStruct [LInt 32, LInt 32],
            initializer = Just (LStruct [MkWithType (LInt 32) (LInt 10), MkWithType (LInt 32) (LInt 20)]),
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "struct_operations",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LStruct [LInt 32, LInt 32]) [] (Just "point")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock (Just "entry") [
                -- Extract x coordinate
                Operation (Local "x") (AggregateOp (ExtractValue 
                    (MkWithType (LStruct [LInt 32, LInt 32]) (LConstE (LPtr (Local "point")))) 0)),
                -- Extract y coordinate
                Operation (Local "y") (AggregateOp (ExtractValue 
                    (MkWithType (LStruct [LInt 32, LInt 32]) (LConstE (LPtr (Local "point")))) 1)),
                -- Calculate sum
                Operation (Local "sum") (BinaryOp Add (LInt 32) (LConstE (LPtr (Local "x"))) (LConstE (LPtr (Local "y")))),
                -- Create new struct with modified values
                Operation (Local "new_point") (AggregateOp (InsertValue 
                    (MkWithType (LStruct [LInt 32, LInt 32]) (LConstE (LPtr (Local "point"))))
                    (MkWithType (LInt 32) (LConstE (LPtr (Local "sum"))))
                    0))
            ] (Ret (LInt 32) (LConstE (LPtr (Local "sum"))))),
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with aliases and IFuncs
moduleWithAliases : LModule
moduleWithAliases = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Function to be aliased
        FunctionDefC $ MkFunctionDef {
            name = "original_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "x")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock (Just "entry") [
                Operation (Local "result") (BinaryOp Mul (LInt 32) (LConstE (LPtr (Local "x"))) (LConstE (LInt 2)))
            ] (Ret (LInt 32) (LConstE (LPtr (Local "result"))))],
            tags = []
        },
        -- Alias to the function
        AliasC $ MkAlias {
            name = "function_alias",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            aliasTpe = LFun (LInt 32) [LInt 32],
            aliasee = "original_function",
            tags = []
        },
        -- IFunc with resolver
        IFuncC $ MkIFunc {
            name = "dynamic_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            funTpe = LFun (LInt 32) [LInt 32],
            resTpe = LPtr,
            resolver = "function_resolver",
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with exception handling and personality functions
moduleWithExceptions : LModule
moduleWithExceptions = MkLModule {
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        -- Declare exception handling personality function
        FunctionDecC $ MkFunctionDec {
            name = "__gxx_personality_v0",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] Nothing, MkFunctionArgSpec (LInt 32) [] Nothing, MkFunctionArgSpec (LInt 64) [] Nothing, MkFunctionArgSpec LPtr [] Nothing, MkFunctionArgSpec LPtr [] Nothing],
            addressInfo = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "exception_test",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "x")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Just (LPtr (Global "__gxx_personality_v0")),
            metadata = [],
            body = [
                MkBlock (Just "entry") [
                    -- Invoke that might throw
                    Operation (Local "result") (TerminatorOp (Invoke (MkInvokeCall (Just C) [] Nothing 
                        (LFun (LInt 32) [LInt 32]) 
                        (LConstE (LPtr (Global "might_throw"))) 
                        [LConstE (LPtr (Local "x"))]
                        (LConstE (LPtr (Local "normal")))
                        (LConstE (LPtr (Local "exception"))))))
                ] (JumpBr (LVar (Local "normal"))),
                
                MkBlock (Just "normal") [
                ] (Ret (LInt 32) (LVar (Local "result"))),
                
                MkBlock (Just "exception") [
                    -- Landing pad for exception handling (simplified for demo)
                    Operation (Local "landing_pad") (BinaryOp Add (LInt 32) (LConstE (LInt 0)) (LConstE (LInt 0)))
                ] (Ret (LInt 32) (LConstE (LInt (-1))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with atomic operations and memory ordering
moduleWithAtomics : LModule
moduleWithAtomics = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Global atomic counter
        GlobalDefC $ MkGVarDef {
            name = "atomic_counter",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LInt 32,
            initializer = Just (LInt 0),
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "atomic_operations",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "value")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock (Just "entry") [
                -- Simple memory operations using MemoryOp variants
                Operation (Local "old_value") (MemoryOp (LoadRegular False (LInt 32)
                    (LConstE (LPtr (Global "atomic_counter")))
                    Nothing False False False False Nothing Nothing Nothing False)),
                -- Store atomic value
                Operation Trash (MemoryOp (StoreRegular False
                    (MkWithType (LInt 32) (LConstE (LPtr (Local "value"))))
                    (LConstE (LPtr (Global "atomic_counter")))
                    Nothing False False)),
                -- Memory fence
                Operation Trash (MemoryOp (Fence Nothing (Just SequentiallyConsistent)))
            ] (Ret (LInt 32) (LVar (Local "old_value")))],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with inline assembly
moduleWithInlineAssembly : LModule
moduleWithInlineAssembly = MkLModule {
    dataLayout = Nothing,
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "inline_asm_test",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkFunctionArgSpec (LInt 32) [] (Just "a"),
                MkFunctionArgSpec (LInt 32) [] (Just "b")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock (Just "entry") [
                -- Inline assembly to add two numbers (simplified for demo)
                Operation (Local "result") (BinaryOp Add (LInt 32) (LVar (Local "a")) (LVar (Local "b")))
            ] (Ret (LInt 32) (LVar (Local "result")))],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with debug information and metadata
moduleWithDebugInfo : LModule
moduleWithDebugInfo = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "debug_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "param")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock (Just "entry") [
                -- Allocate local variable
                Operation (Local "local_var_ptr") (MemoryOp (Alloc (LInt 32) Nothing Nothing Nothing)),
                -- Calculate the value
                Operation (Local "local_var") (BinaryOp Add (LInt 32) (LVar (Local "param")) (LConstE (LInt 1))),
                -- Store the value
                Operation Trash (MemoryOp (StoreRegular False 
                    (MkWithType (LInt 32) (LVar (Local "local_var")))
                    (LVar (Local "local_var_ptr"))
                    Nothing False False)),
                -- Call debug intrinsic with pointer
                Operation Trash (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun LVoid [LPtr, LPtr, LPtr]) 
                    (LConstE (LPtr (Global "llvm.dbg.declare"))) 
                    [
                        MkWithType LPtr (LVar (Local "local_var_ptr")),
                        MkWithType LPtr (LConstE LNull),
                        MkWithType LPtr (LConstE LNull)
                    ] [])))
            ] (Ret (LInt 32) (LVar (Local "local_var")))],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with complex nested structures and packed types
moduleWithComplexTypes : LModule
moduleWithComplexTypes = MkLModule {
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Nothing,
    text = [
        -- Complex nested struct type
        GlobalDefC $ MkGVarDef {
            name = "complex_struct",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LStruct [
                LInt 8,  -- flags
                LPackedStruct [LInt 16, LInt 16],  -- packed coordinates
                LArray 10 (LFloating LDouble),    -- array of doubles
                LStruct [                         -- nested struct
                    LPtr,                         -- pointer
                    LVector 4 (LInt 32),         -- vector
                    LFun LVoid [LInt 32]         -- function pointer
                ]
            ],
            initializer = Nothing,
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "process_complex_type",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LVoid,
            args = [MkFunctionArgSpec LPtr [] (Just "complex_ptr")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock (Just "entry") [
                -- Get element pointer using a simpler approach
                Operation (Local "nested_ptr") (AggregateOp (ExtractValue
                    (MkWithType (LStruct [
                        LInt 8,  -- flags
                        LPackedStruct [LInt 16, LInt 16],  -- packed coordinates
                        LArray 10 (LFloating LDouble),    -- array of doubles
                        LStruct [                         -- nested struct
                            LPtr,                         -- pointer
                            LVector 4 (LInt 32),         -- vector
                            LFun LVoid [LInt 32]         -- function pointer
                        ]
                    ]) (LConstE (LPtr (Local "complex_ptr")))) 3)),
                -- Extract vector from nested struct
                Operation (Local "vector_ptr") (AggregateOp (ExtractValue
                    (MkWithType (LStruct [LPtr, LVector 4 (LInt 32), LFun LVoid [LInt 32]]) 
                     (LConstE (LPtr (Local "nested_ptr")))) 1)),
                -- Load the vector using simple load
                Operation (Local "vector") (MemoryOp (LoadRegular False (LVector 4 (LInt 32))
                    (LConstE (LPtr (Local "vector_ptr")))
                    Nothing False False False False Nothing Nothing Nothing False))
            ] RetVoid),
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with function attributes and parameter attributes
moduleWithAttributes : LModule
moduleWithAttributes = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "attributed_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [NoAlias],  -- Return attributes
            returnType = LPtr,
            args = [
                MkFunctionArgSpec LPtr [NoAlias] (Just "input"),   -- No alias
                MkFunctionArgSpec (LInt 32) [ZeroExt] (Just "size"),               -- Zero extend
                MkFunctionArgSpec LPtr [NoAlias] (Just "output")                -- No alias
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],  -- Function attributes
            section = Just ".text.hot",
            partition = Nothing,
            comdat = Nothing,
            alignment = Just 16,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock (Just "entry") [
                -- Memory copy with attributes
                Operation Trash (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun LVoid [LPtr, LPtr, LInt 32]) 
                    (LConstE (LPtr (Global "llvm.memcpy.p0i8.p0i8.i32"))) 
                    [
                        MkWithType LPtr (LConstE (LPtr (Local "output"))),
                        MkWithType LPtr (LConstE (LPtr (Local "input"))),
                        MkWithType (LInt 32) (LConstE (LPtr (Local "size")))
                    ] []))),
                Operation Trash (TerminatorOp (Ret LPtr (LConstE (LPtr (Local "output")))))
            ] RetVoid),
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with edge cases and error conditions
moduleWithEdgeCases : LModule
moduleWithEdgeCases = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Zero-sized array
        GlobalDefC $ MkGVarDef {
            name = "zero_array",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = True,
            gtpe = LArray 0 (LInt 8),
            initializer = Just LZero,
            tags = []
        },
        -- Function with unusual control flow
        FunctionDefC $ MkFunctionDef {
            name = "edge_case_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "input")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock (Just "entry") [
                -- Division by potentially zero value
                Operation (Local "div_result") (BinaryOp SDiv (LInt 32) (LConstE (LInt 100)) (LVar (Local "input"))),
                -- Check for overflow (proper comparison)
                Operation (Local "overflow_check") (icmp CNe (LInt 32) (LVar (Local "input")) (LConstE (LInt 0))),
                Operation Trash (TerminatorOp (CondBr (LVar (Local "overflow_check")) (LConstE (LPtr (Local "error"))) (LConstE (LPtr (Local "normal")))))
            ] (CondBr (LVar (Local "overflow_check")) (LConstE (LPtr (Local "error"))) (LConstE (LPtr (Local "normal"))))),
                
            MkBlock (Just "error") [
                -- Unreachable after error
                Operation Trash (TerminatorOp (Ret (LInt 32) (LConstE (LInt (-1))))),
                Operation Trash (TerminatorOp Unreachable)  -- This should never be reached
            ] (Ret (LInt 32) (LConstE (LInt (-1)))),
                
            MkBlock (Just "normal") [
                -- Phi node with single predecessor (edge case)
                Operation (Local "phi_result") (MiscOp (Phi (LInt 32) [
                    (LConstE (LPtr (Local "div_result")), LConstE (LPtr (Local "entry")))
                ])),
                Operation Trash (TerminatorOp (Ret (LInt 32) (LConstE (LPtr (Local "phi_result")))))
            ] (Ret (LInt 32) (LConstE (LPtr (Local "phi_result"))))],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module testing memory management and allocation
moduleWithMemoryManagement : LModule
moduleWithMemoryManagement = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Declare malloc and free
        FunctionDecC $ MkFunctionDec {
            name = "malloc",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [NoAlias],
            returnType = LPtr,
            args = [MkFunctionArgSpec (LInt 64) [] Nothing],
            addressInfo = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            tags = []
        },
        FunctionDecC $ MkFunctionDec {
            name = "free",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LVoid,
            args = [MkFunctionArgSpec LPtr [] Nothing],
            addressInfo = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "memory_test",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LPtr,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "size")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock (Just "entry") [
                -- Convert size to 64-bit for malloc
                Operation (Local "size64") (ConversionOp ZExt (MkWithType (LInt 32) (LVar (Local "size"))) (LInt 64)),
                -- Allocate memory
                Operation (Local "ptr") (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun LPtr [LInt 64]) 
                    (LConstE (LPtr (Global "malloc"))) 
                    [MkWithType (LInt 64) (LVar (Local "size64"))] []))),
                -- Check if allocation succeeded (proper pointer comparison)
                Operation (Local "is_null") (icmp CEq LPtr (LVar (Local "ptr")) (LConstE LNull)),
                Operation Trash (TerminatorOp (CondBr (LVar (Local "is_null")) (LConstE (LPtr (Local "alloc_failed"))) (LConstE (LPtr (Local "alloc_success")))))
            ] (CondBr (LVar (Local "is_null")) (LConstE (LPtr (Local "alloc_failed"))) (LConstE (LPtr (Local "alloc_success"))))),
                
            MkBlock (Just "alloc_failed") [
                Operation Trash (TerminatorOp (Ret LPtr (LConstE LNull)))
            ] (Ret LPtr (LConstE LNull)),
                
            MkBlock (Just "alloc_success") [
                -- Initialize allocated memory to zero
                Operation Trash (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun LVoid [LPtr, LInt 8, LInt 64]) 
                    (LConstE (LPtr (Global "llvm.memset.p0i8.i64"))) 
                    [
                        MkWithType LPtr (LVar (Local "ptr")),
                        MkWithType (LInt 8) (LConstE (LInt 0)),
                        MkWithType (LInt 64) (LVar (Local "size64"))
                    ] []))),
                Operation Trash (TerminatorOp (Ret LPtr (LVar (Local "ptr"))))
            ] (Ret LPtr (LVar (Local "ptr")))],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module for testing intrinsic functions and LLVM builtins
moduleWithIntrinsics : LModule
moduleWithIntrinsics = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "main",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LFloating LDouble,
            args = [
                MkFunctionArgSpec (LFloating LDouble) [] (Just "x"),
                MkFunctionArgSpec (LFloating LDouble) [] (Just "y")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock (Just "entry") [
                -- Call sqrt intrinsic
                Operation (Local "sqrt_x") (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun (LFloating LDouble) [LFloating LDouble]) 
                    (LConstE (LPtr (Global "llvm.sqrt.f64"))) 
                    [MkWithType (LFloating LDouble) (LConstE (LPtr (Local "x")))] []))),
                -- Call sin intrinsic
                Operation (Local "sin_y") (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun (LFloating LDouble) [LFloating LDouble]) 
                    (LConstE (LPtr (Global "llvm.sin.f64"))) 
                    [MkWithType (LFloating LDouble) (LConstE (LPtr (Local "y")))] []))),
                -- Call fma (fused multiply-add) intrinsic
                Operation (Local "fma_result") (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun (LFloating LDouble) [LFloating LDouble, LFloating LDouble, LFloating LDouble]) 
                    (LConstE (LPtr (Global "llvm.fma.f64"))) 
                    [
                        MkWithType (LFloating LDouble) (LConstE (LPtr (Local "sqrt_x"))),
                        MkWithType (LFloating LDouble) (LConstE (LPtr (Local "sin_y"))),
                        MkWithType (LFloating LDouble) (LConstE (LFloat "1.0"))
                    ] []))),
                -- Check for NaN using intrinsic
                Operation (Local "is_nan") (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun (LInt 1) [LFloating LDouble]) 
                    (LConstE (LPtr (Global "llvm.isnan.f64"))) 
                    [MkWithType (LFloating LDouble) (LConstE (LPtr (Local "fma_result")))] []))),
                -- Select result based on NaN check
                Operation (Local "final_result") (MiscOp (Select [] 
                    (MkWithType (LInt 1) (LConstE (LPtr (Local "is_nan"))))
                    (MkWithType (LFloating LDouble) (LConstE (LFloat "0.0"))) 
                    (MkWithType (LFloating LDouble) (LConstE (LPtr (Local "fma_result")))))),
                Operation Trash (TerminatorOp (Ret (LFloating LDouble) (LConstE (LPtr (Local "final_result")))))
            ] (Ret (LFloating LDouble) (LConstE (LPtr (Local "final_result"))))),
            tags = []
        }
    ],
    tags = Nothing
}

-- Module for testing garbage collection and stack maps
moduleWithGC : LModule
moduleWithGC = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "gc_test",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LPtr,
            args = [MkFunctionArgSpec LPtr [] (Just "root")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Just "shadow-stack",  -- Use shadow stack GC
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock (Just "entry") [
                -- GC root declaration
                Operation Trash (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun LVoid [LPtr, LPtr]) 
                    (LConstE (LPtr (Global "llvm.gcroot"))) 
                    [
                        MkWithType LPtr (LConstE (LPtr (Local "root"))),
                        MkWithType LPtr (LConstE LNull)
                    ] []))),
                -- Potential GC safepoint
                Operation Trash (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun LVoid []) 
                    (LConstE (LPtr (Global "llvm.experimental.gc.statepoint.p0f_isVoidf"))) 
                    [] []))),
                -- Read from GC pointer
                Operation (Local "value") (MemoryOp (LoadRegular False LPtr
                    (LConstE (LPtr (Local "root")))
                    Nothing False False False False Nothing Nothing Nothing False)),
                Operation Trash (TerminatorOp (Ret LPtr (LConstE (LPtr (Local "value")))))
            ] (Ret LPtr (LConstE (LPtr (Local "value"))))),
            tags = []
        }
    ],
    tags = Nothing
}

-- Module for testing constant expressions and global constructors
moduleWithConstants : LModule
moduleWithConstants = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Global constructor
        GlobalDefC $ MkGVarDef {
            name = "llvm.global_ctors",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LArray 1 (LStruct [LInt 32, LPtr, LPtr]),
            initializer = Nothing,
            tags = []
        },
        -- Global destructor
        GlobalDefC $ MkGVarDef {
            name = "llvm.global_dtors",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LArray 1 (LStruct [LInt 32, LPtr, LPtr]),
            initializer = Nothing,
            tags = []
        },
        -- Complex constant expression
        GlobalDefC $ MkGVarDef {
            name = "complex_constant",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = True,
            gtpe = LPtr,
            initializer = Just LNull,
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "constructor",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LVoid,
            args = [],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock (Just "entry") [
                -- Initialize global state
                Operation Trash (MemoryOp (StoreRegular False
                    (MkWithType (LInt 32) (LConstE (LInt 42)))
                    (LConstE (LPtr (Global "initialized_value")))
                    Nothing False False))
            ] RetVoid],
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "destructor",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LVoid,
            args = [],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock (Just "entry") [
                -- Cleanup global state
                Operation Trash (MemoryOp (StoreRegular False
                    (MkWithType (LInt 32) (LConstE (LInt 0)))
                    (LConstE (LPtr (Global "initialized_value")))
                    Nothing False False)),
                Operation Trash (TerminatorOp RetVoid)
            ] RetVoid),
            tags = []
        },
        GlobalDefC $ MkGVarDef {
            name = "initialized_value",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LInt 32,
            initializer = Just (LInt 0),
            tags = []
        }
    ],
    tags = Nothing
}

-- Module for testing comdats and linkage edge cases
moduleWithComdats : LModule
moduleWithComdats = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Global with weak linkage and comdat
        GlobalDefC $ MkGVarDef {
            name = "weak_global",
            symbolInfo = MkSymbolInfo (Just WeakODR) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LInt 32,
            initializer = Just (LInt 100),
            tags = []
        },
        -- Function with linkonce linkage
        FunctionDefC $ MkFunctionDef {
            name = "linkonce_function",
            symbolInfo = MkSymbolInfo (Just LinkOnceODR) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Just (Global "linkonce_function"),  -- Comdat group
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock (Just "entry") [
                Operation (Local "value") (MemoryOp (LoadRegular False (LInt 32)
                    (LConstE (LPtr (Global "weak_global")))
                    Nothing False False False False Nothing Nothing Nothing False))
            ] (Ret (LInt 32) (LVar (Local "value")))],
            tags = []
        },
        -- Available externally function (template instantiation)
        FunctionDefC $ MkFunctionDef {
            name = "template_instantiation",
            symbolInfo = MkSymbolInfo (Just Available) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LVoid,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "param")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock (Just "entry") [
                -- Template-like operation
                Operation (Local "result") (BinaryOp Mul (LInt 32) (LVar (Local "param")) (LVar (Local "param"))),
                Operation Trash (MemoryOp (StoreRegular False
                    (MkWithType (LInt 32) (LVar (Local "result")))
                    (LConstE (LPtr (Global "weak_global")))
                    Nothing False False))
            ] RetVoid),
            tags = []
        }
    ],
    tags = Nothing
}

-- Module for stress testing with many functions and complex control flow
moduleStressTest : LModule
moduleStressTest = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Many small functions to test scale
        FunctionDefC $ MkFunctionDef {
            name = "stress_function_1",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "x")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock (Just "entry") [
                Operation (Local "result") (BinaryOp Add (LInt 32) (LVar (Local "x")) (LConstE (LInt 1)))
            ] (Ret (LInt 32) (LVar (Local "result")))],
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "stress_function_2",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "x")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock (Just "entry") [
                Operation (Local "result") (BinaryOp Mul (LInt 32) (LConstE (LPtr (Local "x"))) (LConstE (LInt 2))),
                Operation Trash (TerminatorOp (Ret (LInt 32) (LConstE (LPtr (Local "result")))))
            ] (Ret (LInt 32) (LConstE (LPtr (Local "result"))))],
            tags = []
        },
        -- Function with deeply nested control flow
        FunctionDefC $ MkFunctionDef {
            name = "deeply_nested",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "depth")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = [MkBlock (Just "entry") [
                Operation (Local "cmp1") (icmp CSGt (LInt 32) (LVar (Local "depth")) (LConstE (LInt 0)))
            ] (CondBr (LVar (Local "cmp1")) (LVar (Local "level1")) (LVar (Local "base"))),
                
            MkBlock (Just "level1") [
                Operation (Local "cmp2") (icmp CSGt (LInt 32) (LVar (Local "depth")) (LConstE (LInt 1)))
            ] (CondBr (LVar (Local "cmp2")) (LVar (Local "level2")) (LVar (Local "base"))),
                
            MkBlock (Just "level2") [
                Operation (Local "cmp3") (icmp CSGt (LInt 32) (LVar (Local "depth")) (LConstE (LInt 2)))
            ] (CondBr (LVar (Local "cmp3")) (LVar (Local "level3")) (LVar (Local "base"))),
                
            MkBlock (Just "level3") [
                Operation (Local "sub") (BinaryOp Sub (LInt 32) (LVar (Local "depth")) (LConstE (LInt 1))),
                Operation (Local "recursive") (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun (LInt 32) [LInt 32]) 
                    (LConstE (LPtr (Global "deeply_nested"))) 
                    [MkWithType (LInt 32) (LVar (Local "sub"))] [])))
            ] (JumpBr (LVar (Local "base"))),
                
            MkBlock (Just "base") [
                Operation (Local "phi") (MiscOp (Phi (LInt 32) [
                    (LConstE (LInt 0), LVar (Local "entry")),
                    (LConstE (LInt 1), LVar (Local "level1")),
                    (LConstE (LInt 2), LVar (Local "level2")),
                    (LVar (Local "recursive"), LVar (Local "level3"))
                ]))
            ] (Ret (LInt 32) (LVar (Local "phi")))],
            tags = []
        }
    ],
    tags = Nothing
}

public export
moduleTests : IO ()
moduleTests = do
    putStrLn "=== Running LLVM Module Tests ==="
    
    -- Test simple empty module
    debugTest "Empty Module" Test.Groups.Module.emptyModule

    -- Test module with global variables
    debugTest "Module with Global Variables" moduleWithGlobals
    
    -- Test module with simple function
    debugTest "Module with Simple Function" moduleWithSimpleFunction
    
    -- Test module with function that has operations
    debugTest "Module with Function Operations" moduleWithOperations
    
    -- Test complete module with multiple components
    debugTest "Complete Module" completeModule
    
    -- Test module with thread-local storage
    debugTest "Module with Thread-Local Storage" moduleWithTLS
    
    -- Test module with various calling conventions
    debugTest "Module with Calling Conventions" moduleWithCallingConventions
    
    -- Test module with vector operations
    debugTest "Module with Vector Operations" moduleWithVectors
    
    -- Test module with control flow and phi nodes
    debugTest "Module with Control Flow" moduleWithControlFlow
    
    -- Test module with switch statements
    debugTest "Module with Switch Statements" moduleWithSwitch
    
    -- Test module with struct operations
    debugTest "Module with Struct Operations" moduleWithStructs
    
    -- Test module with aliases and IFuncs
    debugTest "Module with Aliases and IFuncs" moduleWithAliases
    
    -- Test module with exception handling
    debugTest "Module with Exception Handling" moduleWithExceptions
    
    -- Test module with atomic operations
    debugTest "Module with Atomic Operations" moduleWithAtomics
    
    -- Test module with inline assembly
    debugTest "Module with Inline Assembly" moduleWithInlineAssembly
    
    -- Test module with debug information
    debugTest "Module with Debug Information" moduleWithDebugInfo
    
    -- Test module with complex nested structures
    debugTest "Module with Complex Nested Structures" moduleWithComplexTypes
    
    -- Test module with function attributes
    debugTest "Module with Function Attributes" moduleWithAttributes
    
    -- Test module with edge cases
    debugTest "Module with Edge Cases" moduleWithEdgeCases
    
    -- Test module with memory management
    debugTest "Module with Memory Management" moduleWithMemoryManagement
    
    -- Test module with intrinsics
    debugTest "Module with Intrinsics" moduleWithIntrinsics
    
    -- Test module with garbage collection
    debugTest "Module with GC" moduleWithGC
    
    -- Test module with constants and constructors
    debugTest "Module with Constants" moduleWithConstants
    
    -- Test module with comdats and linkage
    debugTest "Module with Comdats" moduleWithComdats
    
    -- Stress test module
    debugTest "Module Stress Test" moduleStressTest
    
    putStrLn "=== All Module Tests Completed ==="



    -- Test simple empty module
    debugFileTest "Empty Module" Test.Groups.Module.emptyModule

    -- Test module with global variables
    debugFileTest "Module with Global Variables" moduleWithGlobals
    
    -- Test module with simple function
    debugFileTest "Module with Simple Function" moduleWithSimpleFunction
    
    -- Test module with function that has operations
    debugFileTest "Module with Function Operations" moduleWithOperations
    
    -- Test complete module with multiple components
    debugFileTest "Complete Module" completeModule
    
    -- Test module with thread-local storage
    debugFileTest "Module with Thread-Local Storage" moduleWithTLS
    
    -- Test module with various calling conventions
    debugFileTest "Module with Calling Conventions" moduleWithCallingConventions
    
    -- Test module with vector operations
    debugFileTest "Module with Vector Operations" moduleWithVectors
    
    -- Test module with control flow and phi nodes
    debugFileTest "Module with Control Flow" moduleWithControlFlow
    
    -- Test module with switch statements
    debugFileTest "Module with Switch Statements" moduleWithSwitch
    
    -- Test module with struct operations
    debugFileTest "Module with Struct Operations" moduleWithStructs
    
    -- Test module with aliases and IFuncs
    debugFileTest "Module with Aliases and IFuncs" moduleWithAliases
    
    -- Test module with exception handling
    debugFileTest "Module with Exception Handling" moduleWithExceptions
    
    -- Test module with atomic operations
    debugFileTest "Module with Atomic Operations" moduleWithAtomics
    
    -- Test module with inline assembly
    debugFileTest "Module with Inline Assembly" moduleWithInlineAssembly
    
    -- Test module with debug information
    debugFileTest "Module with Debug Information" moduleWithDebugInfo
    
    -- Test module with complex nested structures
    debugFileTest "Module with Complex Nested Structures" moduleWithComplexTypes
    
    -- Test module with function attributes
    debugFileTest "Module with Function Attributes" moduleWithAttributes
    
    -- Test module with edge cases
    debugFileTest "Module with Edge Cases" moduleWithEdgeCases
    
    -- Test module with memory management
    debugFileTest "Module with Memory Management" moduleWithMemoryManagement
    
    -- Test module with intrinsics
    debugFileTest "Module with Intrinsics" moduleWithIntrinsics
    
    -- Test module with garbage collection
    debugFileTest "Module with GC" moduleWithGC
    
    -- Test module with constants and constructors
    debugFileTest "Module with Constants" moduleWithConstants
    
    -- Test module with comdats and linkage
    debugFileTest "Module with Comdats" moduleWithComdats
    
    -- Stress test module
    debugFileTest "Module Stress Test" moduleStressTest





    -- Test simple empty module
    --debugCompile "EmptyModule" Test.Groups.Module.emptyModule

    -- Test module with global variables
    debugCompile "Module_with_Global_Variables" moduleWithGlobals
    
    -- Test module with simple function
    debugCompile "Module_with_Simple_Function" moduleWithSimpleFunction
    
    -- Test module with function that has operations
    debugCompile "Module_with_Function_Operations" moduleWithOperations
    
    -- Test complete module with multiple components
    debugCompile "Complete_Module" completeModule
    
    -- Test module with thread-local storage
    debugCompile "Module_with_Thread_Local_Storage" moduleWithTLS
    
    -- Test module with various calling conventions
    debugCompile "Module_with_Calling_Conventions" moduleWithCallingConventions
    
    -- Test module with vector operations
    debugCompile "Module_with_Vector_Operations" moduleWithVectors
    
    -- Test module with control flow and phi nodes
    debugCompile "Module_with_Control_Flow" moduleWithControlFlow
    
    -- Test module with switch statements
    debugCompile "Module_with_Switch_Statements" moduleWithSwitch
    
    -- Test module with struct operations
    debugCompile "Module_with_Struct_Operations" moduleWithStructs
    
    -- Test module with aliases and IFuncs
    debugCompile "Module_with_Aliases_and_IFuncs" moduleWithAliases
    
    -- Test module with exception handling
    debugCompile "Module_with_Exception_Handling" moduleWithExceptions
    
    -- Test module with atomic operations
    debugCompile "Module_with_Atomic_Operations" moduleWithAtomics
    
    -- Test module with inline assembly
    debugCompile "Module_with_Inline_Assembly" moduleWithInlineAssembly
    
    -- Test module with debug information
    debugCompile "Module_with_Debug_Information" moduleWithDebugInfo
    
    -- Test module with complex nested structures
    debugCompile "Module_with_Complex_Nested_Structures" moduleWithComplexTypes
    
    -- Test module with function attributes
    debugCompile "Module_with_Function_Attributes" moduleWithAttributes
    
    -- Test module with edge cases
    debugCompile "Module_with_Edge_Cases" moduleWithEdgeCases
    
    -- Test module with memory management
    debugCompile "Module_with_Memory_Management" moduleWithMemoryManagement
    
    -- Test module with intrinsics
    debugCompile "Module_with_Intrinsics" moduleWithIntrinsics
    
    -- Test module with garbage collection
    debugCompile "Module_with_GC" moduleWithGC
    
    -- Test module with constants and constructors
    debugCompile "Module_with_Constants" moduleWithConstants
    
    -- Test module with comdats and linkage
    debugCompile "Module_with_Comdats" moduleWithComdats
    
    -- Stress test module
    debugCompile "Module_Stress_Test" moduleStressTest