-- NOTE: A large portion of this file was generated by AI

module Test.Groups.Module

import Data.LLVM
import Data.LLVM.IR
import Data.LLVM.Write
import Data.LLVM.Class
import Test.Helper


-- Helper functions to create test modules

emptyModule : LModule
emptyModule = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [],
    tags = Nothing
}

moduleWithGlobals : LModule
moduleWithGlobals = MkLModule {
    
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        -- Global integer variable
        GlobalDefC $ MkGVarDef {
            name = "global_counter",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LInt 32,
            initializer = Just (LInt 42),
            tags = []
        },
        -- Global constant string
        GlobalDefC $ MkGVarDef {
            name = "hello_string",
            symbolInfo = MkSymbolInfo (Just Private) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = True,
            gtpe = LArray 13 (LInt 8),
            initializer = Just (LString "Hello, World!\\00"),
            tags = []
        }
    ],
    tags = Nothing
}

moduleWithSimpleFunction : LModule
moduleWithSimpleFunction = MkLModule {
    
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "simple_add",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkFunctionArgSpec (LInt 32) [] (Just "a"),
                MkFunctionArgSpec (LInt 32) [] (Just "b")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                Targeted (Local "result") (BinaryOp Add (LInt 32) (LConstE (LPtr (Local "a"))) (LConstE (LPtr (Local "b")))),
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LPtr (Local "result")))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

moduleWithOperations : LModule
moduleWithOperations = MkLModule {
    
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "main",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkFunctionArgSpec (LInt 32) [] (Just "x"),
                MkFunctionArgSpec (LInt 32) [] (Just "y")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                -- Multiply x and y
                Targeted (Local "mul_result") (BinaryOp Mul (LInt 32) (LConstE (LPtr (Local "x"))) (LConstE (LPtr (Local "y")))),
                -- Add 10 to the result
                Targeted (Local "add_result") (BinaryOp Add (LInt 32) (LConstE (LPtr (Local "mul_result"))) (LConstE (LInt 10))),
                -- Shift left by 1
                Targeted (Local "shift_result") (BinaryOp Shl (LInt 32) (LConstE (LPtr (Local "add_result"))) (LConstE (LInt 1))),
                -- Return the final result
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LPtr (Local "shift_result")))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

completeModule : LModule
completeModule = MkLModule {
    
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        -- Global array
        GlobalDefC $ MkGVarDef {
            name = "data_array",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = True,
            gtpe = LArray 5 (LInt 32),
            initializer = Just (LArray [MkWithType (LInt 32) (LInt 1), MkWithType (LInt 32) (LInt 2), MkWithType (LInt 32) (LInt 3), MkWithType (LInt 32) (LInt 4), MkWithType (LInt 32) (LInt 5)]),
            tags = []
        },
        -- Main function
        FunctionDefC $ MkFunctionDef {
            name = "main",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkFunctionArgSpec (LInt 32) [] (Just "argc"),
                MkFunctionArgSpec LPtr [] (Just "argv")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                -- Allocate local variable
                Targeted (Local "local_var") (MemoryOp (Alloc (LInt 32) Nothing Nothing Nothing)),
                -- Call helper function
                Targeted (Local "call_result") (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing (LFun (LInt 32) [LInt 32, LInt 32]) (LConstE (LPtr (Global "helper_function"))) [MkWithType (LInt 32) (LConstE (LInt 5)), MkWithType (LInt 32) (LConstE (LInt 10))] []))),
                -- Conditional branch based on result
                Discarded (TerminatorOp (CondBr (LConstE (LPtr (Local "call_result"))) (LConstE (LPtr (Local "success_block"))) (LConstE (LPtr (Local "failure_block"))))),
                Labelled "success_block",
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LInt 0)))),
                Labelled "failure_block",
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LInt 1))))
            ],
            tags = []
        },
        -- Helper function
        FunctionDefC $ MkFunctionDef {
            name = "helper_function",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkFunctionArgSpec (LInt 32) [] (Just "a"),
                MkFunctionArgSpec (LInt 32) [] (Just "b")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                -- Perform various operations
                Targeted (Local "sum") (BinaryOp Add (LInt 32) (LConstE (LPtr (Local "a"))) (LConstE (LPtr (Local "b")))),
                Targeted (Local "diff") (BinaryOp Sub (LInt 32) (LConstE (LPtr (Local "a"))) (LConstE (LPtr (Local "b")))),
                Targeted (Local "product") (BinaryOp Mul (LInt 32) (LConstE (LPtr (Local "sum"))) (LConstE (LPtr (Local "diff")))),
                -- Use aggregate operation
                Targeted (Local "array_val") (AggregateOp (ExtractValue (MkWithType (LArray 5 (LInt 32)) (LConstE (LPtr (Global "data_array")))) 0)),
                Targeted (Local "final_result") (BinaryOp Add (LInt 32) (LConstE (LPtr (Local "product"))) (LConstE (LPtr (Local "array_val")))),
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LPtr (Local "final_result")))))
            ],
            tags = []
        },
    
        -- External function declaration
        FunctionDecC $ MkFunctionDec {
            name = "printf",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec LPtr [] Nothing],
            addressInfo = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with thread-local storage and address spaces
moduleWithTLS : LModule
moduleWithTLS = MkLModule {
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        -- Thread-local variable
        GlobalDefC $ MkGVarDef {
            name = "tls_counter",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Just LocalDynamic,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LInt 32,
            initializer = Just (LInt 0),
            tags = []
        },
        -- Global in specific address space
        GlobalDefC $ MkGVarDef {
            name = "gpu_memory",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Just (UnnamedSpace 1),
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LArray 1024 (LInt 8),
            initializer = Nothing,
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with various calling conventions
moduleWithCallingConventions : LModule
moduleWithCallingConventions = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Fast calling convention function
        FunctionDefC $ MkFunctionDef {
            name = "fast_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just Fast,
            returnAttrs = [],
            returnType = LFloating LFloat,
            args = [
                MkFunctionArgSpec (LFloating LFloat) [] (Just "x"),
                MkFunctionArgSpec (LFloating LFloat) [] (Just "y")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                Targeted (Local "result") (BinaryOp (FAdd []) (LFloating LFloat) (LConstE (LPtr (Local "x"))) (LConstE (LPtr (Local "y")))),
                Discarded (TerminatorOp (Ret (LFloating LFloat) (LConstE (LPtr (Local "result")))))
            ],
            tags = []
        },
        -- Cold calling convention function (rarely called)
        FunctionDefC $ MkFunctionDef {
            name = "error_handler",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            callingConvention = Just Cold,
            returnAttrs = [],
            returnType = LVoid,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "error_code")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                -- Call printf to report error
                Targeted (Local "printf_result") (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun (LInt 32) [LPtr]) 
                    (LConstE (LPtr (Global "printf"))) 
                    [MkWithType LPtr (LConstE (LPtr (Global "error_format")))] []))),
                Discarded (TerminatorOp RetVoid)
            ],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with vector operations
moduleWithVectors : LModule
moduleWithVectors = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "vector_operations",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LVector 4 (LInt 32),
            args = [
                MkFunctionArgSpec (LVector 4 (LInt 32)) [] (Just "vec1"),
                MkFunctionArgSpec (LVector 4 (LInt 32)) [] (Just "vec2")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                -- Extract element from first vector
                Targeted (Local "elem1") (VectorOp (ExtractElement 
                    (MkWithType (LVector 4 (LInt 32)) (LConstE (LPtr (Local "vec1"))))
                    (MkWithType (LInt 32) (LConstE (LInt 0))))),
                -- Insert element into second vector
                Targeted (Local "modified_vec") (VectorOp (InsertElement 
                    (MkWithType (LVector 4 (LInt 32)) (LConstE (LPtr (Local "vec2"))))
                    (MkWithType (LInt 32) (LConstE (LPtr (Local "elem1"))))
                    (MkWithType (LInt 32) (LConstE (LInt 1))))),
                -- Shuffle vectors
                Targeted (Local "shuffled") (VectorOp (ShuffleVector
                    (MkWithType (LVector 4 (LInt 32)) (LConstE (LPtr (Local "vec1"))))
                    (MkWithType (LVector 4 (LInt 32)) (LConstE (LPtr (Local "modified_vec"))))
                    (MkWithType (LVector 4 (LInt 32)) (LConstE (LVector [
                        MkWithType (LInt 32) (LInt 0),
                        MkWithType (LInt 32) (LInt 5),
                        MkWithType (LInt 32) (LInt 2),
                        MkWithType (LInt 32) (LInt 7)
                    ]))))),
                Discarded (TerminatorOp (Ret (LVector 4 (LInt 32)) (LConstE (LPtr (Local "shuffled")))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with control flow and phi nodes
moduleWithControlFlow : LModule
moduleWithControlFlow = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "fibonacci",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "n")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                -- Check if n <= 1 (simplified as subtraction)
                Targeted (Local "cmp") (BinaryOp Sub (LInt 32) (LConstE (LPtr (Local "n"))) (LConstE (LInt 1))),
                Discarded (TerminatorOp (CondBr (LConstE (LPtr (Local "cmp"))) (LConstE (LPtr (Local "base_case"))) (LConstE (LPtr (Local "recursive_case"))))),
                
                Labelled "base_case",
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LPtr (Local "n"))))),
                
                Labelled "recursive_case",
                -- Calculate fib(n-1)
                Targeted (Local "n_minus_1") (BinaryOp Sub (LInt 32) (LConstE (LPtr (Local "n"))) (LConstE (LInt 1))),
                Targeted (Local "fib_n_minus_1") (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun (LInt 32) [LInt 32]) 
                    (LConstE (LPtr (Global "fibonacci"))) 
                    [MkWithType (LInt 32) (LConstE (LPtr (Local "n_minus_1")))] []))),
                -- Calculate fib(n-2)
                Targeted (Local "n_minus_2") (BinaryOp Sub (LInt 32) (LConstE (LPtr (Local "n"))) (LConstE (LInt 2))),
                Targeted (Local "fib_n_minus_2") (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun (LInt 32) [LInt 32]) 
                    (LConstE (LPtr (Global "fibonacci"))) 
                    [MkWithType (LInt 32) (LConstE (LPtr (Local "n_minus_2")))] []))),
                -- Add results
                Targeted (Local "result") (BinaryOp Add (LInt 32) (LConstE (LPtr (Local "fib_n_minus_1"))) (LConstE (LPtr (Local "fib_n_minus_2")))),
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LPtr (Local "result")))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with switch statements and multiple cases
moduleWithSwitch : LModule
moduleWithSwitch = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "handle_opcode",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "opcode")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                Discarded (TerminatorOp (Switch (LInt 32) (LConstE (LPtr (Local "opcode"))) (Local "default") [
                    MkCaseBranch (LInt 32) (LConstE (LInt 1)) (LConstE (LPtr (Local "case_add"))),
                    MkCaseBranch (LInt 32) (LConstE (LInt 2)) (LConstE (LPtr (Local "case_sub"))),
                    MkCaseBranch (LInt 32) (LConstE (LInt 3)) (LConstE (LPtr (Local "case_mul"))),
                    MkCaseBranch (LInt 32) (LConstE (LInt 4)) (LConstE (LPtr (Local "case_div")))
                ])),
                
                Labelled "case_add",
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LInt 100)))),
                
                Labelled "case_sub",
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LInt 200)))),
                
                Labelled "case_mul",
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LInt 300)))),
                
                Labelled "case_div",
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LInt 400)))),
                
                Labelled "default",
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LInt (-1)))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with struct operations and complex types
moduleWithStructs : LModule
moduleWithStructs = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Global struct
        GlobalDefC $ MkGVarDef {
            name = "global_point",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LStruct [LInt 32, LInt 32],
            initializer = Just (LStruct [MkWithType (LInt 32) (LInt 10), MkWithType (LInt 32) (LInt 20)]),
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "struct_operations",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LStruct [LInt 32, LInt 32]) [] (Just "point")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                -- Extract x coordinate
                Targeted (Local "x") (AggregateOp (ExtractValue 
                    (MkWithType (LStruct [LInt 32, LInt 32]) (LConstE (LPtr (Local "point")))) 0)),
                -- Extract y coordinate
                Targeted (Local "y") (AggregateOp (ExtractValue 
                    (MkWithType (LStruct [LInt 32, LInt 32]) (LConstE (LPtr (Local "point")))) 1)),
                -- Calculate sum
                Targeted (Local "sum") (BinaryOp Add (LInt 32) (LConstE (LPtr (Local "x"))) (LConstE (LPtr (Local "y")))),
                -- Create new struct with modified values
                Targeted (Local "new_point") (AggregateOp (InsertValue 
                    (MkWithType (LStruct [LInt 32, LInt 32]) (LConstE (LPtr (Local "point"))))
                    (MkWithType (LInt 32) (LConstE (LPtr (Local "sum"))))
                    0)),
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LPtr (Local "sum")))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with aliases and IFuncs
moduleWithAliases : LModule
moduleWithAliases = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Function to be aliased
        FunctionDefC $ MkFunctionDef {
            name = "original_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "x")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                Targeted (Local "result") (BinaryOp Mul (LInt 32) (LConstE (LPtr (Local "x"))) (LConstE (LInt 2))),
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LPtr (Local "result")))))
            ],
            tags = []
        },
        -- Alias to the function
        AliasC $ MkAlias {
            name = "function_alias",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            aliasTpe = LFun (LInt 32) [LInt 32],
            aliasee = "original_function",
            tags = []
        },
        -- IFunc with resolver
        IFuncC $ MkIFunc {
            name = "dynamic_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            funTpe = LFun (LInt 32) [LInt 32],
            resTpe = LPtr,
            resolver = "function_resolver",
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with exception handling and personality functions
moduleWithExceptions : LModule
moduleWithExceptions = MkLModule {
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        -- Declare exception handling personality function
        FunctionDecC $ MkFunctionDec {
            name = "__gxx_personality_v0",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] Nothing, MkFunctionArgSpec (LInt 32) [] Nothing, MkFunctionArgSpec (LInt 64) [] Nothing, MkFunctionArgSpec LPtr [] Nothing, MkFunctionArgSpec LPtr [] Nothing],
            addressInfo = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "exception_test",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "x")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Just (LPtr (Global "__gxx_personality_v0")),
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                -- Invoke that might throw
                Targeted (Local "result") (TerminatorOp (Invoke (MkInvokeCall (Just C) [] Nothing 
                    (LFun (LInt 32) [LInt 32]) 
                    (LConstE (LPtr (Global "might_throw"))) 
                    [LConstE (LPtr (Local "x"))]
                    (LConstE (LPtr (Local "normal")))
                    (LConstE (LPtr (Local "exception")))))),
                
                Labelled "normal",
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LPtr (Local "result"))))),
                
                Labelled "exception",
                -- Landing pad for exception handling (simplified for demo)
                Targeted (Local "landing_pad") (BinaryOp Add (LInt 32) (LConstE (LInt 0)) (LConstE (LInt 0))),
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LInt (-1)))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with atomic operations and memory ordering
moduleWithAtomics : LModule
moduleWithAtomics = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Global atomic counter
        GlobalDefC $ MkGVarDef {
            name = "atomic_counter",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LInt 32,
            initializer = Just (LInt 0),
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "atomic_operations",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "value")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                -- Simple memory operations using MemoryOp variants
                Targeted (Local "old_value") (MemoryOp (LoadRegular False (LInt 32)
                    (LConstE (LPtr (Global "atomic_counter")))
                    Nothing False False False False Nothing Nothing Nothing False)),
                -- Store atomic value
                Discarded (MemoryOp (StoreRegular False
                    (MkWithType (LInt 32) (LConstE (LPtr (Local "value"))))
                    (LConstE (LPtr (Global "atomic_counter")))
                    Nothing False False)),
                -- Memory fence
                Discarded (MemoryOp (Fence Nothing (Just SequentiallyConsistent))),
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LPtr (Local "old_value")))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with inline assembly
moduleWithInlineAssembly : LModule
moduleWithInlineAssembly = MkLModule {
    dataLayout = Nothing,
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "inline_asm_test",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [
                MkFunctionArgSpec (LInt 32) [] (Just "a"),
                MkFunctionArgSpec (LInt 32) [] (Just "b")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                -- Inline assembly to add two numbers (simplified for demo)
                Targeted (Local "result") (BinaryOp Add (LInt 32) (LConstE (LPtr (Local "a"))) (LConstE (LPtr (Local "b")))),
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LPtr (Local "result")))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with debug information and metadata
moduleWithDebugInfo : LModule
moduleWithDebugInfo = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "debug_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "param")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                -- Add debug location
                Targeted (Local "local_var") (BinaryOp Add (LInt 32) (LConstE (LPtr (Local "param"))) (LConstE (LInt 1))),
                -- Call debug intrinsic
                Discarded (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun LVoid [LPtr, LPtr, LPtr]) 
                    (LConstE (LPtr (Global "llvm.dbg.declare"))) 
                    [
                        MkWithType LPtr (LConstE (LPtr (Local "local_var"))),
                        MkWithType LPtr (LConstE LNull),
                        MkWithType LPtr (LConstE LNull)
                    ] []))),
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LPtr (Local "local_var")))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with complex nested structures and packed types
moduleWithComplexTypes : LModule
moduleWithComplexTypes = MkLModule {
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Nothing,
    text = [
        -- Complex nested struct type
        GlobalDefC $ MkGVarDef {
            name = "complex_struct",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LStruct [
                LInt 8,  -- flags
                LPackedStruct [LInt 16, LInt 16],  -- packed coordinates
                LArray 10 (LFloating LDouble),    -- array of doubles
                LStruct [                         -- nested struct
                    LPtr,                         -- pointer
                    LVector 4 (LInt 32),         -- vector
                    LFun LVoid [LInt 32]         -- function pointer
                ]
            ],
            initializer = Nothing,
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "process_complex_type",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LVoid,
            args = [MkFunctionArgSpec LPtr [] (Just "complex_ptr")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                -- Get element pointer using a simpler approach
                Targeted (Local "nested_ptr") (AggregateOp (ExtractValue
                    (MkWithType (LStruct [
                        LInt 8,  -- flags
                        LPackedStruct [LInt 16, LInt 16],  -- packed coordinates
                        LArray 10 (LFloating LDouble),    -- array of doubles
                        LStruct [                         -- nested struct
                            LPtr,                         -- pointer
                            LVector 4 (LInt 32),         -- vector
                            LFun LVoid [LInt 32]         -- function pointer
                        ]
                    ]) (LConstE (LPtr (Local "complex_ptr")))) 3)),
                -- Extract vector from nested struct
                Targeted (Local "vector_ptr") (AggregateOp (ExtractValue
                    (MkWithType (LStruct [LPtr, LVector 4 (LInt 32), LFun LVoid [LInt 32]]) 
                     (LConstE (LPtr (Local "nested_ptr")))) 1)),
                -- Load the vector using simple load
                Targeted (Local "vector") (MemoryOp (LoadRegular False (LVector 4 (LInt 32))
                    (LConstE (LPtr (Local "vector_ptr")))
                    Nothing False False False False Nothing Nothing Nothing False)),
                Discarded (TerminatorOp RetVoid)
            ],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with function attributes and parameter attributes
moduleWithAttributes : LModule
moduleWithAttributes = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "attributed_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [NoAlias],  -- Return attributes
            returnType = LPtr,
            args = [
                MkFunctionArgSpec LPtr [NoAlias] (Just "input"),   -- No alias
                MkFunctionArgSpec (LInt 32) [ZeroExt] (Just "size"),               -- Zero extend
                MkFunctionArgSpec LPtr [NoAlias] (Just "output")                -- No alias
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],  -- Function attributes
            section = Just ".text.hot",
            partition = Nothing,
            comdat = Nothing,
            alignment = Just 16,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                -- Memory copy with attributes
                Discarded (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun LVoid [LPtr, LPtr, LInt 32]) 
                    (LConstE (LPtr (Global "llvm.memcpy.p0i8.p0i8.i32"))) 
                    [
                        MkWithType LPtr (LConstE (LPtr (Local "output"))),
                        MkWithType LPtr (LConstE (LPtr (Local "input"))),
                        MkWithType (LInt 32) (LConstE (LPtr (Local "size")))
                    ] []))),
                Discarded (TerminatorOp (Ret LPtr (LConstE (LPtr (Local "output")))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module with edge cases and error conditions
moduleWithEdgeCases : LModule
moduleWithEdgeCases = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Zero-sized array
        GlobalDefC $ MkGVarDef {
            name = "zero_array",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = True,
            gtpe = LArray 0 (LInt 8),
            initializer = Just LZero,
            tags = []
        },
        -- Function with unusual control flow
        FunctionDefC $ MkFunctionDef {
            name = "edge_case_function",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "input")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                -- Division by potentially zero value
                Targeted (Local "div_result") (BinaryOp SDiv (LInt 32) (LConstE (LInt 100)) (LConstE (LPtr (Local "input")))),
                -- Check for overflow (simplified as subtraction)
                Targeted (Local "overflow_check") (BinaryOp Sub (LInt 32) (LConstE (LPtr (Local "input"))) (LConstE (LInt 0))),
                Discarded (TerminatorOp (CondBr (LConstE (LPtr (Local "overflow_check"))) (LConstE (LPtr (Local "error"))) (LConstE (LPtr (Local "normal"))))),
                
                Labelled "error",
                -- Unreachable after error
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LInt (-1))))),
                Discarded (TerminatorOp Unreachable),  -- This should never be reached
                
                Labelled "normal",
                -- Phi node with single predecessor (edge case)
                Targeted (Local "phi_result") (MiscOp (Phi (LInt 32) [
                    (LConstE (LPtr (Local "div_result")), LConstE (LPtr (Local "entry")))
                ])),
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LPtr (Local "phi_result")))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module testing memory management and allocation
moduleWithMemoryManagement : LModule
moduleWithMemoryManagement = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Declare malloc and free
        FunctionDecC $ MkFunctionDec {
            name = "malloc",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [NoAlias],
            returnType = LPtr,
            args = [MkFunctionArgSpec (LInt 64) [] Nothing],
            addressInfo = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            tags = []
        },
        FunctionDecC $ MkFunctionDec {
            name = "free",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LVoid,
            args = [MkFunctionArgSpec LPtr [] Nothing],
            addressInfo = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "memory_test",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LPtr,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "size")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                -- Convert size to 64-bit for malloc
                Targeted (Local "size64") (ConversionOp ZExt (MkWithType (LInt 32) (LConstE (LPtr (Local "size")))) (LInt 64)),
                -- Allocate memory
                Targeted (Local "ptr") (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun LPtr [LInt 64]) 
                    (LConstE (LPtr (Global "malloc"))) 
                    [MkWithType (LInt 64) (LConstE (LPtr (Local "size64")))] []))),
                -- Check if allocation succeeded (simplified as add)
                Targeted (Local "is_null") (BinaryOp Add LPtr (LConstE (LPtr (Local "ptr"))) (LConstE LNull)),
                Discarded (TerminatorOp (CondBr (LConstE (LPtr (Local "is_null"))) (LConstE (LPtr (Local "alloc_failed"))) (LConstE (LPtr (Local "alloc_success"))))),
                
                Labelled "alloc_failed",
                Discarded (TerminatorOp (Ret LPtr (LConstE LNull))),
                
                Labelled "alloc_success",
                -- Initialize allocated memory to zero
                Discarded (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun LVoid [LPtr, LInt 8, LInt 64]) 
                    (LConstE (LPtr (Global "llvm.memset.p0i8.i64"))) 
                    [
                        MkWithType LPtr (LConstE (LPtr (Local "ptr"))),
                        MkWithType (LInt 8) (LConstE (LInt 0)),
                        MkWithType (LInt 64) (LConstE (LPtr (Local "size64")))
                    ] []))),
                Discarded (TerminatorOp (Ret LPtr (LConstE (LPtr (Local "ptr")))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module for testing intrinsic functions and LLVM builtins
moduleWithIntrinsics : LModule
moduleWithIntrinsics = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "main",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LFloating LDouble,
            args = [
                MkFunctionArgSpec (LFloating LDouble) [] (Just "x"),
                MkFunctionArgSpec (LFloating LDouble) [] (Just "y")
            ],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                -- Call sqrt intrinsic
                Targeted (Local "sqrt_x") (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun (LFloating LDouble) [LFloating LDouble]) 
                    (LConstE (LPtr (Global "llvm.sqrt.f64"))) 
                    [MkWithType (LFloating LDouble) (LConstE (LPtr (Local "x")))] []))),
                -- Call sin intrinsic
                Targeted (Local "sin_y") (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun (LFloating LDouble) [LFloating LDouble]) 
                    (LConstE (LPtr (Global "llvm.sin.f64"))) 
                    [MkWithType (LFloating LDouble) (LConstE (LPtr (Local "y")))] []))),
                -- Call fma (fused multiply-add) intrinsic
                Targeted (Local "fma_result") (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun (LFloating LDouble) [LFloating LDouble, LFloating LDouble, LFloating LDouble]) 
                    (LConstE (LPtr (Global "llvm.fma.f64"))) 
                    [
                        MkWithType (LFloating LDouble) (LConstE (LPtr (Local "sqrt_x"))),
                        MkWithType (LFloating LDouble) (LConstE (LPtr (Local "sin_y"))),
                        MkWithType (LFloating LDouble) (LConstE (LFloat "1.0"))
                    ] []))),
                -- Check for NaN using intrinsic
                Targeted (Local "is_nan") (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun (LInt 1) [LFloating LDouble]) 
                    (LConstE (LPtr (Global "llvm.isnan.f64"))) 
                    [MkWithType (LFloating LDouble) (LConstE (LPtr (Local "fma_result")))] []))),
                -- Select result based on NaN check
                Targeted (Local "final_result") (MiscOp (Select [] 
                    (MkWithType (LInt 1) (LConstE (LPtr (Local "is_nan"))))
                    (MkWithType (LFloating LDouble) (LConstE (LFloat "0.0"))) 
                    (MkWithType (LFloating LDouble) (LConstE (LPtr (Local "fma_result")))))),
                Discarded (TerminatorOp (Ret (LFloating LDouble) (LConstE (LPtr (Local "final_result")))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module for testing garbage collection and stack maps
moduleWithGC : LModule
moduleWithGC = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        FunctionDefC $ MkFunctionDef {
            name = "gc_test",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LPtr,
            args = [MkFunctionArgSpec LPtr [] (Just "root")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Just "shadow-stack",  -- Use shadow stack GC
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                -- GC root declaration
                Discarded (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun LVoid [LPtr, LPtr]) 
                    (LConstE (LPtr (Global "llvm.gcroot"))) 
                    [
                        MkWithType LPtr (LConstE (LPtr (Local "root"))),
                        MkWithType LPtr (LConstE LNull)
                    ] []))),
                -- Potential GC safepoint
                Discarded (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun LVoid []) 
                    (LConstE (LPtr (Global "llvm.experimental.gc.statepoint.p0f_isVoidf"))) 
                    [] []))),
                -- Read from GC pointer
                Targeted (Local "value") (MemoryOp (LoadRegular False LPtr
                    (LConstE (LPtr (Local "root")))
                    Nothing False False False False Nothing Nothing Nothing False)),
                Discarded (TerminatorOp (Ret LPtr (LConstE (LPtr (Local "value")))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module for testing constant expressions and global constructors
moduleWithConstants : LModule
moduleWithConstants = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Global constructor
        GlobalDefC $ MkGVarDef {
            name = "llvm.global_ctors",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LArray 1 (LStruct [LInt 32, LPtr, LPtr]),
            initializer = Nothing,
            tags = []
        },
        -- Global destructor
        GlobalDefC $ MkGVarDef {
            name = "llvm.global_dtors",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LArray 1 (LStruct [LInt 32, LPtr, LPtr]),
            initializer = Nothing,
            tags = []
        },
        -- Complex constant expression
        GlobalDefC $ MkGVarDef {
            name = "complex_constant",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = True,
            gtpe = LPtr,
            initializer = Just LNull,
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "constructor",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LVoid,
            args = [],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                -- Initialize global state
                Discarded (MemoryOp (StoreRegular False
                    (MkWithType (LInt 32) (LConstE (LInt 42)))
                    (LConstE (LPtr (Global "initialized_value")))
                    Nothing False False)),
                Discarded (TerminatorOp RetVoid)
            ],
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "destructor",
            symbolInfo = MkSymbolInfo (Just Internal) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LVoid,
            args = [],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                -- Cleanup global state
                Discarded (MemoryOp (StoreRegular False
                    (MkWithType (LInt 32) (LConstE (LInt 0)))
                    (LConstE (LPtr (Global "initialized_value")))
                    Nothing False False)),
                Discarded (TerminatorOp RetVoid)
            ],
            tags = []
        },
        GlobalDefC $ MkGVarDef {
            name = "initialized_value",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LInt 32,
            initializer = Just (LInt 0),
            tags = []
        }
    ],
    tags = Nothing
}

-- Module for testing comdats and linkage edge cases
moduleWithComdats : LModule
moduleWithComdats = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Global with weak linkage and comdat
        GlobalDefC $ MkGVarDef {
            name = "weak_global",
            symbolInfo = MkSymbolInfo (Just WeakODR) Nothing (Just Default) Nothing,
            threadLocality = Nothing,
            addressInfo = Nothing,
            addressSpace = Nothing,
            externallyInitialized = Nothing,
            isConst = False,
            gtpe = LInt 32,
            initializer = Just (LInt 100),
            tags = []
        },
        -- Function with linkonce linkage
        FunctionDefC $ MkFunctionDef {
            name = "linkonce_function",
            symbolInfo = MkSymbolInfo (Just LinkOnceODR) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Just (Global "linkonce_function"),  -- Comdat group
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                Targeted (Local "value") (MemoryOp (LoadRegular False (LInt 32)
                    (LConstE (LPtr (Global "weak_global")))
                    Nothing False False False False Nothing Nothing Nothing False)),
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LPtr (Local "value")))))
            ],
            tags = []
        },
        -- Available externally function (template instantiation)
        FunctionDefC $ MkFunctionDef {
            name = "template_instantiation",
            symbolInfo = MkSymbolInfo (Just Available) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LVoid,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "param")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                -- Template-like operation
                Targeted (Local "result") (BinaryOp Mul (LInt 32) (LConstE (LPtr (Local "param"))) (LConstE (LPtr (Local "param")))),
                Discarded (MemoryOp (StoreRegular False
                    (MkWithType (LInt 32) (LConstE (LPtr (Local "result"))))
                    (LConstE (LPtr (Global "weak_global")))
                    Nothing False False)),
                Discarded (TerminatorOp RetVoid)
            ],
            tags = []
        }
    ],
    tags = Nothing
}

-- Module for stress testing with many functions and complex control flow
moduleStressTest : LModule
moduleStressTest = MkLModule {
    dataLayout = Nothing,
    target = Nothing,
    text = [
        -- Many small functions to test scale
        FunctionDefC $ MkFunctionDef {
            name = "stress_function_1",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "x")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                Targeted (Local "result") (BinaryOp Add (LInt 32) (LConstE (LPtr (Local "x"))) (LConstE (LInt 1))),
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LPtr (Local "result")))))
            ],
            tags = []
        },
        FunctionDefC $ MkFunctionDef {
            name = "stress_function_2",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "x")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                Targeted (Local "result") (BinaryOp Mul (LInt 32) (LConstE (LPtr (Local "x"))) (LConstE (LInt 2))),
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LPtr (Local "result")))))
            ],
            tags = []
        },
        -- Function with deeply nested control flow
        FunctionDefC $ MkFunctionDef {
            name = "deeply_nested",
            symbolInfo = MkSymbolInfo (Just External) Nothing (Just Default) Nothing,
            callingConvention = Just C,
            returnAttrs = [],
            returnType = LInt 32,
            args = [MkFunctionArgSpec (LInt 32) [] (Just "depth")],
            addressInfo = Nothing,
            addressSpace = Nothing,
            fnAttributes = [],
            section = Nothing,
            partition = Nothing,
            comdat = Nothing,
            alignment = Nothing,
            gc = Nothing,
            fprefix = Nothing,
            prologue = Nothing,
            personality = Nothing,
            metadata = [],
            body = MkFunctionBody [
                Labelled "entry",
                Targeted (Local "cmp1") (BinaryOp Sub (LInt 32) (LConstE (LPtr (Local "depth"))) (LConstE (LInt 0))),
                Discarded (TerminatorOp (CondBr (LConstE (LPtr (Local "cmp1"))) (LConstE (LPtr (Local "level1"))) (LConstE (LPtr (Local "base"))))),
                
                Labelled "level1",
                Targeted (Local "cmp2") (BinaryOp Sub (LInt 32) (LConstE (LPtr (Local "depth"))) (LConstE (LInt 1))),
                Discarded (TerminatorOp (CondBr (LConstE (LPtr (Local "cmp2"))) (LConstE (LPtr (Local "level2"))) (LConstE (LPtr (Local "base"))))),
                
                Labelled "level2",
                Targeted (Local "cmp3") (BinaryOp Sub (LInt 32) (LConstE (LPtr (Local "depth"))) (LConstE (LInt 2))),
                Discarded (TerminatorOp (CondBr (LConstE (LPtr (Local "cmp3"))) (LConstE (LPtr (Local "level3"))) (LConstE (LPtr (Local "base"))))),
                
                Labelled "level3",
                Targeted (Local "sub") (BinaryOp Sub (LInt 32) (LConstE (LPtr (Local "depth"))) (LConstE (LInt 1))),
                Targeted (Local "recursive") (MiscOp (FnCallOp (MkFnCall NoTail [] (Just C) [] Nothing 
                    (LFun (LInt 32) [LInt 32]) 
                    (LConstE (LPtr (Global "deeply_nested"))) 
                    [MkWithType (LInt 32) (LConstE (LPtr (Local "sub")))] []))),
                Discarded (TerminatorOp (JumpBr (LConstE (LPtr (Local "base"))))),
                
                Labelled "base",
                Targeted (Local "phi") (MiscOp (Phi (LInt 32) [
                    (LConstE (LInt 0), LConstE (LPtr (Local "entry"))),
                    (LConstE (LInt 1), LConstE (LPtr (Local "level1"))),
                    (LConstE (LInt 2), LConstE (LPtr (Local "level2"))),
                    (LConstE (LPtr (Local "recursive")), LConstE (LPtr (Local "level3")))
                ])),
                Discarded (TerminatorOp (Ret (LInt 32) (LConstE (LPtr (Local "phi")))))
            ],
            tags = []
        }
    ],
    tags = Nothing
}

public export
moduleTests : IO ()
moduleTests = do
    putStrLn "=== Running LLVM Module Tests ==="
    
    -- Test simple empty module
    debugTest "Empty Module" Test.Groups.Module.emptyModule

    -- Test module with global variables
    debugTest "Module with Global Variables" moduleWithGlobals
    
    -- Test module with simple function
    debugTest "Module with Simple Function" moduleWithSimpleFunction
    
    -- Test module with function that has operations
    debugTest "Module with Function Operations" moduleWithOperations
    
    -- Test complete module with multiple components
    debugTest "Complete Module" completeModule
    
    -- Test module with thread-local storage
    debugTest "Module with Thread-Local Storage" moduleWithTLS
    
    -- Test module with various calling conventions
    debugTest "Module with Calling Conventions" moduleWithCallingConventions
    
    -- Test module with vector operations
    debugTest "Module with Vector Operations" moduleWithVectors
    
    -- Test module with control flow and phi nodes
    debugTest "Module with Control Flow" moduleWithControlFlow
    
    -- Test module with switch statements
    debugTest "Module with Switch Statements" moduleWithSwitch
    
    -- Test module with struct operations
    debugTest "Module with Struct Operations" moduleWithStructs
    
    -- Test module with aliases and IFuncs
    debugTest "Module with Aliases and IFuncs" moduleWithAliases
    
    -- Test module with exception handling
    debugTest "Module with Exception Handling" moduleWithExceptions
    
    -- Test module with atomic operations
    debugTest "Module with Atomic Operations" moduleWithAtomics
    
    -- Test module with inline assembly
    debugTest "Module with Inline Assembly" moduleWithInlineAssembly
    
    -- Test module with debug information
    debugTest "Module with Debug Information" moduleWithDebugInfo
    
    -- Test module with complex nested structures
    debugTest "Module with Complex Nested Structures" moduleWithComplexTypes
    
    -- Test module with function attributes
    debugTest "Module with Function Attributes" moduleWithAttributes
    
    -- Test module with edge cases
    debugTest "Module with Edge Cases" moduleWithEdgeCases
    
    -- Test module with memory management
    debugTest "Module with Memory Management" moduleWithMemoryManagement
    
    -- Test module with intrinsics
    debugTest "Module with Intrinsics" moduleWithIntrinsics
    
    -- Test module with garbage collection
    debugTest "Module with GC" moduleWithGC
    
    -- Test module with constants and constructors
    debugTest "Module with Constants" moduleWithConstants
    
    -- Test module with comdats and linkage
    debugTest "Module with Comdats" moduleWithComdats
    
    -- Stress test module
    debugTest "Module Stress Test" moduleStressTest
    
    putStrLn "=== All Module Tests Completed ==="



    -- Test simple empty module
    debugFileTest "Empty Module" Test.Groups.Module.emptyModule

    -- Test module with global variables
    debugFileTest "Module with Global Variables" moduleWithGlobals
    
    -- Test module with simple function
    debugFileTest "Module with Simple Function" moduleWithSimpleFunction
    
    -- Test module with function that has operations
    debugFileTest "Module with Function Operations" moduleWithOperations
    
    -- Test complete module with multiple components
    debugFileTest "Complete Module" completeModule
    
    -- Test module with thread-local storage
    debugFileTest "Module with Thread-Local Storage" moduleWithTLS
    
    -- Test module with various calling conventions
    debugFileTest "Module with Calling Conventions" moduleWithCallingConventions
    
    -- Test module with vector operations
    debugFileTest "Module with Vector Operations" moduleWithVectors
    
    -- Test module with control flow and phi nodes
    debugFileTest "Module with Control Flow" moduleWithControlFlow
    
    -- Test module with switch statements
    debugFileTest "Module with Switch Statements" moduleWithSwitch
    
    -- Test module with struct operations
    debugFileTest "Module with Struct Operations" moduleWithStructs
    
    -- Test module with aliases and IFuncs
    debugFileTest "Module with Aliases and IFuncs" moduleWithAliases
    
    -- Test module with exception handling
    debugFileTest "Module with Exception Handling" moduleWithExceptions
    
    -- Test module with atomic operations
    debugFileTest "Module with Atomic Operations" moduleWithAtomics
    
    -- Test module with inline assembly
    debugFileTest "Module with Inline Assembly" moduleWithInlineAssembly
    
    -- Test module with debug information
    debugFileTest "Module with Debug Information" moduleWithDebugInfo
    
    -- Test module with complex nested structures
    debugFileTest "Module with Complex Nested Structures" moduleWithComplexTypes
    
    -- Test module with function attributes
    debugFileTest "Module with Function Attributes" moduleWithAttributes
    
    -- Test module with edge cases
    debugFileTest "Module with Edge Cases" moduleWithEdgeCases
    
    -- Test module with memory management
    debugFileTest "Module with Memory Management" moduleWithMemoryManagement
    
    -- Test module with intrinsics
    debugFileTest "Module with Intrinsics" moduleWithIntrinsics
    
    -- Test module with garbage collection
    debugFileTest "Module with GC" moduleWithGC
    
    -- Test module with constants and constructors
    debugFileTest "Module with Constants" moduleWithConstants
    
    -- Test module with comdats and linkage
    debugFileTest "Module with Comdats" moduleWithComdats
    
    -- Stress test module
    debugFileTest "Module Stress Test" moduleStressTest





    -- Test simple empty module
    --debugCompile "EmptyModule" Test.Groups.Module.emptyModule

    -- Test module with global variables
    debugCompile "Module_with_Global_Variables" moduleWithGlobals
    
    -- Test module with simple function
    debugCompile "Module_with_Simple_Function" moduleWithSimpleFunction
    
    -- Test module with function that has operations
    debugCompile "Module_with_Function_Operations" moduleWithOperations
    
    -- Test complete module with multiple components
    debugCompile "Complete_Module" completeModule
    
    -- Test module with thread-local storage
    debugCompile "Module_with_Thread_Local_Storage" moduleWithTLS
    
    -- Test module with various calling conventions
    debugCompile "Module_with_Calling_Conventions" moduleWithCallingConventions
    
    -- Test module with vector operations
    debugCompile "Module_with_Vector_Operations" moduleWithVectors
    
    -- Test module with control flow and phi nodes
    debugCompile "Module_with_Control_Flow" moduleWithControlFlow
    
    -- Test module with switch statements
    debugCompile "Module_with_Switch_Statements" moduleWithSwitch
    
    -- Test module with struct operations
    debugCompile "Module_with_Struct_Operations" moduleWithStructs
    
    -- Test module with aliases and IFuncs
    debugCompile "Module_with_Aliases_and_IFuncs" moduleWithAliases
    
    -- Test module with exception handling
    debugCompile "Module_with_Exception_Handling" moduleWithExceptions
    
    -- Test module with atomic operations
    debugCompile "Module_with_Atomic_Operations" moduleWithAtomics
    
    -- Test module with inline assembly
    debugCompile "Module_with_Inline_Assembly" moduleWithInlineAssembly
    
    -- Test module with debug information
    debugCompile "Module_with_Debug_Information" moduleWithDebugInfo
    
    -- Test module with complex nested structures
    debugCompile "Module_with_Complex_Nested_Structures" moduleWithComplexTypes
    
    -- Test module with function attributes
    debugCompile "Module_with_Function_Attributes" moduleWithAttributes
    
    -- Test module with edge cases
    debugCompile "Module_with_Edge_Cases" moduleWithEdgeCases
    
    -- Test module with memory management
    debugCompile "Module_with_Memory_Management" moduleWithMemoryManagement
    
    -- Test module with intrinsics
    debugCompile "Module_with_Intrinsics" moduleWithIntrinsics
    
    -- Test module with garbage collection
    debugCompile "Module_with_GC" moduleWithGC
    
    -- Test module with constants and constructors
    debugCompile "Module_with_Constants" moduleWithConstants
    
    -- Test module with comdats and linkage
    debugCompile "Module_with_Comdats" moduleWithComdats
    
    -- Stress test module
    debugCompile "Module_Stress_Test" moduleStressTest