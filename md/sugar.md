# LLVM IR Builder Sugar Operators Reference

> [!NOTE]
> Because I am lazy, a large portion of this file was generated by AI

This document provides a comprehensive reference for all syntactic sugar operators defined in `Data.LLVM.Builders.Sugar`. The operators follow consistent conventions to make LLVM IR construction more readable and concise.

## Operator Convention Overview

The Sugar module follows these basic conventions for operator prefixes:

- **`?`** prefix: Creates variables and references
- **`#`** prefix: Creates constants and literal values  
- **`$`** infix: Creates statements and assignments
- **`!`** prefix: Creates basic blocks, instructions, or arguments
- **`:`** infix: Creates types and type operations
- **`@`** infix: Creates declarations and global definitions
- **`^`** prefix/infix: Creates metadata and annotations
- **`&`** prefix: Creates modifiers and settings

## Variable and Reference Operators

### Variable Creation

| Operator | Precedence | Type | Description | Example |
|----------|------------|------|-------------|---------|
| `?%` | prefix 1 | `String -> LValue False` | Local variable reference | `?% "localVar"` |
| `?@` | prefix 1 | `String -> LValue False` | Global variable reference | `?@ "globalVar"` |
| `?^` | prefix 1 | `String -> LValue False` | Parameter reference | `?^ "param"` |
| `?*` | prefix 18 | `Name -> ALValue` | Pointer expression from name | `?* "ptr"` |
| `?+` | infixr 12 | `String -> List LType -> IntrinsicName` | Intrinsic name creation | `?+ "llvm.sqrt" [double]` |

## Constant and Literal Operators

### Constant Creation

| Operator | Precedence | Type | Description | Example |
|----------|------------|------|-------------|---------|
| `##` | prefix 1 | `Int -> ALValue` | Integer literal constant | `## 42` |
| `#^` | prefix 1 | `String -> Label` | Named label creation | `#^ "loop"` |
| `#!` | prefix 100 | `LExpr -> LValue False` | Complex expression to value | `#! expr` |

## Type Construction Operators

### Type Building

| Operator | Precedence | Type | Description | Example |
|----------|------------|------|-------------|---------|
| `:#` | prefix 1 | `Int -> LType` | Integer type creation | `:#32` for i32 |
| `:->` | infixr 11 | `LType -> LType -> LType` | Function type creation | `i32 :-> i32` |
| `:<>` | infixr 2 | `Int -> LType -> LType` | Vector type creation | `4 :<> (:#32)` |
| `:**` | infixr 2 | `Int -> LType -> LType` | Array type creation | `10 :** (:#32)` |
| `:?` | prefix 18 | `Type -> LType` | Type reflection | `:? Int` |

### Type-Value Combination

| Operator | Precedence | Type | Description | Example |
|----------|------------|------|-------------|---------|
| `<:>` | infix 11 | `a -> LType -> WithType a` | Value-type pairing | `value <:> i32` |
| `<::>` | infixr 11 | `LType -> a -> WithType a` | Type-value pairing | `i32 <::> value` |

## Statement and Assignment Operators

### Statement Creation

| Operator | Precedence | Type | Description | Example |
|----------|------------|------|-------------|---------|
| `<<-` | infixl 70 | `Name -> LExpr -> LStatement` | Assignment statement | `"result" <<- expr` |
| `-<<` | prefix 71 | `LExpr -> LStatement` | Discarded statement | `-<< expr` |

## Basic Block and Control Flow Operators

### Block Construction

| Operator | Precedence | Type | Description | Example |
|----------|------------|------|-------------|---------|
| `!:` | infixr 11 | `String -> (List LStatement, Terminator) -> (String, BasicBlock)` | Named basic block | `"entry" !: (stmts, term)` |
| `!>` | infixr 99 | `List LStatement -> Terminator -> BasicBlock` | Anonymous basic block | `stmts !> term` |
| `!#` | prefix 100 | `BasicBlock -> Label` | Block to label | `!# block` |

### Argument Creation

| Operator | Precedence | Type | Description | Example |
|----------|------------|------|-------------|---------|
| `!^` | infixl 19 | `String -> LType -> Argument` | Named argument | `"param" !^ i32` |
| `!^^` | prefix 1 | `LType -> Argument` | Anonymous argument | `!^^ i32` |

## Declaration and Global Definition Operators

### Global Definitions

| Operator | Precedence | Type | Description | Example |
|----------|------------|------|-------------|---------|
| `@=` | infixl 98 | `String -> WithType (LValue True) -> LClause` | Mutable global variable | `"var" @= (42 <:> i32)` |
| `@<` | infixl 98 | `String -> WithType (LValue True) -> LClause` | Constant global variable | `"const" @< (42 <:> i32)` |
| `@:` | infixl 98 | `String -> LType -> LClause` | Global declaration | `"var" @: i32` |

## Metadata and Annotation Operators

### Metadata Creation

| Operator | Precedence | Type | Description | Example |
|----------|------------|------|-------------|---------|
| `^#` | prefix 20 | `Nat -> Metadata` | Metadata node | `^# 0` |
| `^>` | prefix 20 | `String -> Metadata` | Metadata string | `^> "debug info"` |
| `^^` | infixl 29 | `CanNote a => a -> (String, Metadata) -> a` | Attach annotation | `value ^^ ("tag", metadata)` |

## Modifier and Setting Operators

### Value Modification

| Operator | Precedence | Type | Description | Example |
|----------|------------|------|-------------|---------|
| `&-` | infixl 11 | `Setter a b => a -> (b -> b) -> a` | Apply function modifier | `obj &- (setting field)` |
| `&=` | infixl 11 | `Setter a b => a -> b -> a` | Set field value | `obj &= value` |
| `&+` | infixl 11 | `Monoid b => Setter a b => a -> b -> a` | Append to monoid field | `obj &+ value` |
| `&?` | infixl 11 | `Setter a (Maybe b) => a -> b -> a` | Set Maybe field | `obj &? value` |

## Expression and Computation Operators

### Expression Operations

| Operator | Precedence | Type | Description | Example |
|----------|------------|------|-------------|---------|
| `!<*>` | infixl 21 | Context-dependent | Expression application | `expr1 !<*> expr2` |

## Type Class Implementations

### Automatic Conversions

The Sugar module provides several type class implementations for convenience:

- **`FromString Name`**: Converts strings to local names
- **`FromString Label`**: Converts strings to named labels  
- **`Num (LValue t)`**: Numeric literals create integer values
- **`Num LType`**: Numeric literals create integer types
- **`FromString (LValue t)`**: String literals create string values

## Precedence Groups

The operators are organized into precedence groups to ensure proper parsing:

1. **Prefix variables/literals (1-20)**: `?%`, `?@`, `?^`, `##`, `#^`, `:#`, `!^^`, `^#`, `^>`
2. **Type construction (2-12)**: `:<>`, `:**`, `?+`
3. **Value-type pairing (11)**: `<:>`, `<::>`, `!:`, `&-`, `&=`, `&+`, `&?`
4. **Function types (11)**: `:->`
5. **Expression operations (18-21)**: `?*`, `:?`, `!^`, `!<*>`
6. **Metadata attachment (29)**: `^^`
7. **Statements (70-71)**: `<<-`, `-<<`
8. **Blocks and declarations (98-100)**: `@=`, `@:`, `@<`, `!>`, `!#`, `#!`

## Usage Examples

### Complete Function Definition

```idris
myFunction = functionDef "example" i32 [
    "x" !^ i32,
    "y" !^ i32
] $ [
    "sum" <<- (add i32 (?^ "x") (?^ "y")),
    "result" <<- (mul i32 (?^ "sum") (## 2))
] !> (ret i32 (?^ "result"))
```

### Module with Global Variables

```idris
myModule = MkLModule {
    text = [
        "counter" @= ((## 0) <:> i32),
        "PI" @< ((3.14) <:> double),
        "buffer" @: (100 :** i8)
    ]
}
```

### Vector Operations

```idris
vectorExample = [
    "vec" <<- (insertElement 
        ((4 :<> i32) <::> undef) 
        ((## 42) <:> i32) 
        ((## 0) <:> i32)),
    "elem" <<- (extractElement 
        ((?^ "vec") <:> (4 :<> i32)) 
        ((## 2) <:> i32))
]
```

This comprehensive operator reference enables concise and readable LLVM IR construction while maintaining type safety and following LLVM semantics.