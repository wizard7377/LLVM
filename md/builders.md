# LLVM IR Builders Function Reference

> [!NOTE]
> Because I am lazy, a large portion of this file was generated by AI

This document provides comprehensive documentation for all functions in the `Data.LLVM.Builders` module hierarchy. The builders provide convenient functions for constructing LLVM IR with sensible defaults and optional parameters.

## Module Structure

The `Builders` module is organized into several sub-modules:

- **`Data.LLVM.Builders.Core`**: Basic utilities, constants, and core data structures
- **`Data.LLVM.Builders.Math`**: Arithmetic, bitwise, and comparison operations
- **`Data.LLVM.Builders.Control`**: Memory operations, control flow, and function definitions
- **`Data.LLVM.Builders.Ops`**: Global definitions and advanced operations
- **`Data.LLVM.Builders.Helper`**: Utility functions and type reflection
- **`Data.LLVM.Builders.Sugar`**: Syntactic sugar operators (documented separately)
- **`Data.LLVM.Builders.Inst`**: Setter implementations for record types

## Data.LLVM.Builders.Core

### Basic Utilities

#### `emptyModule : LModule`

Create an empty LLVM module with no data layout, target, clauses, or tags.

Returns a minimal LModule that can be used as a starting point for building LLVM modules or as a default module.

#### `emptySymbolInfo : SymbolInfo`

Create empty symbol information with no linkage, preemption, visibility, or storage.

Returns a default SymbolInfo with all optional fields set to Nothing, suitable as a default for symbols that don't need special attributes.

### Name Creation

#### `local : String -> Name`

Create a local variable reference.

Creates a Name representing a local variable or temporary. Local variables are scoped to the current function and are prefixed with '%' in LLVM IR.

**Parameters:**

- `name`: The string name of the local variable

#### `global : String -> Name`

Create a global variable reference.

Creates a Name representing a global variable or function. Global symbols are visible across translation units and are prefixed with '@' in LLVM IR.

**Parameters:**

- `name`: The string name of the global variable

#### `temporary : Int -> Name`

Create a temporary variable reference.

Creates a Name representing a compiler-generated temporary variable. These are typically numbered sequentially and used for intermediate values.

**Parameters:**

- `id`: The numeric identifier for the temporary

### Constant Creation

#### `mkInt : Int -> ALValue`

Create an integer constant.

Creates an LLVM integer constant from an Idris Int value. The value is directly converted to its LLVM representation.

**Parameters:**

- `i`: The integer value

#### `mkBool : Bool -> ALValue`

Create a boolean constant.

Creates an LLVM boolean (i1) constant from an Idris Bool value. True becomes 1, false becomes 0.

**Parameters:**

- `b`: The boolean value

#### `mkString : String -> ALValue`

Create a string constant.

Creates an LLVM string constant from an Idris String value. The string is stored as a global constant array of i8.

**Parameters:**

- `s`: The string value

#### `mkFloat : String -> ALValue`

Create a floating-point constant.

Creates an LLVM floating-point constant from a string representation. The string should be in a format acceptable to LLVM.

**Parameters:**

- `f`: The floating-point value as a string

#### `mkArray : List (WithType (LValue ?)) -> ALValue`

Create an array constant.

Creates an LLVM array constant from a list of typed constant elements. All elements must have compatible types for the array type.

**Parameters:**

- `elems`: List of typed constant elements for the array

#### `mkStruct : List (WithType (LValue ?)) -> ALValue`

Create a struct constant.

Creates an LLVM struct constant from a list of typed constant fields. The fields are ordered and their types must match the struct definition.

**Parameters:**

- `fields`: List of typed constant fields for the struct

#### `mkVector : List (WithType (LValue ?)) -> ALValue`

Create a vector constant.

Creates an LLVM vector constant from a list of typed constant elements. All elements must have the same type and the count must match the vector type.

**Parameters:**

- `elems`: List of typed constant elements for the vector

#### `constExpr : LValue True -> ALValue`

Create an expression from a constant.

Converts an LLVM constant into an expression that can be used in operations and instructions. This is necessary because LLVM distinguishes between constants and expressions syntactically.

**Parameters:**

- `c`: The constant to convert to an expression

### Statement Creation

#### `assign : Name -> LExpr -> LStatement`

Create a targeted statement (assignment).

Creates a statement that assigns the result of an operation to a target variable. The target becomes the destination for the operation result.

**Parameters:**

- `target`: The target variable name to assign to
- `op`: The operation whose result to assign

#### `discard : LExpr -> LStatement`

Create a discarded statement (no assignment).

Creates a statement that executes an operation but discards its result. This is used for operations that have side effects but whose return value is not needed.

**Parameters:**

- `op`: The operation to execute and discard

### Symbol Information

#### `symbolInfo : {default Nothing lnk : Maybe Linkage} -> {default Nothing prm : Maybe Preemption} -> {default Nothing vis : Maybe Visibility} -> {default Nothing dll : Maybe DLLStorage} -> SymbolInfo`

Create symbol information with linkage, preemption, visibility, and storage options.

Creates a SymbolInfo record that specifies how a symbol should be linked, whether it can be preempted, its visibility scope, and DLL storage class. All parameters are optional with sensible defaults.

**Parameters:**

- `lnk`: Optional linkage type (private, internal, external, etc.)
- `prm`: Optional preemption specification
- `vis`: Optional visibility (default, hidden, protected)
- `dll`: Optional DLL storage class

### Expression Helpers

#### `varExpr : Name -> (LValue ?)`

Create a variable expression from a name.

Creates an LValue that references a variable by name. This can be used in contexts where a value expression is needed.

**Parameters:**

- `name`: The name to create an expression for

#### `localVar : String -> (LValue ?)`

Create a variable expression from a local name.

Creates an LValue that references a local variable by string name. This combines name creation with expression creation.

**Parameters:**

- `name`: The string name of the local variable

#### `globalVar : String -> (LValue ?)`

Create a variable expression from a global name.

Creates an LValue that references a global variable by string name. This combines name creation with expression creation.

**Parameters:**

- `name`: The string name of the global variable

### Metadata Helpers

#### `metadataString : String -> Metadata`

Create a metadata string.

Creates metadata from a string value. String metadata is commonly used for debug information and annotations.

**Parameters:**

- `str`: The string content for the metadata

#### `metadataValue : WithType (LValue ?) -> Metadata`

Create a metadata value.

Creates metadata from a typed value expression. Value metadata can reference other parts of the IR.

**Parameters:**

- `value`: The typed value to use as metadata

#### `metadataCustom : String -> Metadata`

Create custom metadata.

Creates custom metadata from a string. This allows for arbitrary metadata content.

**Parameters:**

- `custom`: The custom metadata content

### Type Builders

#### `vectorType : Int -> LType -> LType`

Create a vector type.

Creates an LLVM vector type with the specified element count and element type.

**Parameters:**

- `count`: The number of elements in the vector
- `elemTy`: The type of each vector element

#### `scalableVectorType : Int -> LType -> LType`

Create a scalable vector type.

Creates an LLVM scalable vector type with the specified element count and element type. Scalable vectors have runtime-determined sizes.

**Parameters:**

- `count`: The minimum number of elements in the vector
- `elemTy`: The type of each vector element

#### `arrayType : Int -> LType -> LType`

Create an array type.

Creates an LLVM array type with the specified element count and element type.

**Parameters:**

- `count`: The number of elements in the array
- `elemTy`: The type of each array element

#### `structType : List LType -> LType`

Create a struct type.

Creates an LLVM struct type with the specified field types.

**Parameters:**

- `fields`: List of types for the struct fields

#### `packedStructType : List LType -> LType`

Create a packed struct type.

Creates an LLVM packed struct type with the specified field types. Packed structs have minimal padding between fields.

**Parameters:**

- `fields`: List of types for the struct fields

#### `functionType : LType -> List LType -> LType`

Create a function type.

Creates an LLVM function type with the specified return type and parameter types.

**Parameters:**

- `retTy`: The return type of the function
- `argTys`: List of parameter types

#### `varArgFunctionType : LType -> List LType -> LType -> LType`

Create a variadic function type.

Creates an LLVM variadic function type with the specified return type, fixed parameter types, and variadic parameter type.

**Parameters:**

- `retTy`: The return type of the function
- `argTys`: List of fixed parameter types
- `varArgTy`: The type for variadic parameters

### Type Shortcuts

#### `i1, i8, i16, i32, i64 : LType`

Integer type shortcuts for common bit widths.

#### `ptr : LType`

Generic pointer type.

#### `float, double : LType`

Floating-point type shortcuts for 32-bit and 64-bit floats.

## Data.LLVM.Builders.Math

### Arithmetic Operations

#### `add : LType -> (LValue False) -> (LValue False) -> LExpr`

Create an add operation.

Creates an integer addition operation between two operands of the same type. The operation performs standard arithmetic addition.

**Parameters:**

- `ty`: The integer type of both operands (must be the same)
- `lhs`: The left-hand side operand
- `rhs`: The right-hand side operand

#### `sub : LType -> (LValue False) -> (LValue False) -> LExpr`

Create a subtract operation.

Creates an integer subtraction operation between two operands of the same type. The operation performs standard arithmetic subtraction (lhs - rhs).

**Parameters:**

- `ty`: The integer type of both operands (must be the same)
- `lhs`: The left-hand side operand (minuend)
- `rhs`: The right-hand side operand (subtrahend)

#### `mul : LType -> (LValue False) -> (LValue False) -> LExpr`

Create a multiply operation.

Creates an integer multiplication operation between two operands of the same type. The operation performs standard arithmetic multiplication.

**Parameters:**

- `ty`: The integer type of both operands (must be the same)
- `lhs`: The left-hand side operand
- `rhs`: The right-hand side operand

#### `udiv : {default False exact : Bool} -> (ty : LType) -> (lhs : (LValue False)) -> (rhs : (LValue False)) -> LExpr`

Create division operation (unsigned).

Creates an unsigned integer division operation. Can optionally be marked as exact if the division is known to be exact.

**Parameters:**

- `exact`: Whether the division is exact (no remainder)
- `ty`: The integer type of both operands
- `lhs`: The dividend (left-hand side operand)
- `rhs`: The divisor (right-hand side operand)

#### `sdiv : {default False exact : Bool} -> (ty : LType) -> (lhs : (LValue False)) -> (rhs : (LValue False)) -> LExpr`

Create division operation (signed).

Creates a signed integer division operation. Can optionally be marked as exact if the division is known to be exact.

**Parameters:**

- `exact`: Whether the division is exact (no remainder)
- `ty`: The integer type of both operands
- `lhs`: The dividend (left-hand side operand)
- `rhs`: The divisor (right-hand side operand)

#### `fdiv : {default [] fastMath : FastMath} -> (ty : LType) -> (lhs : (LValue False)) -> (rhs : (LValue False)) -> LExpr`

Create floating point division operation.

Creates a floating-point division operation with optional fast math flags for optimization.

**Parameters:**

- `fastMath`: Fast math flags for optimization
- `ty`: The floating-point type of both operands
- `lhs`: The dividend (left-hand side operand)
- `rhs`: The divisor (right-hand side operand)

#### `urem : LType -> (LValue False) -> (LValue False) -> LExpr`

Create remainder operation (unsigned).

Creates an unsigned integer remainder operation that returns the remainder of unsigned division.

**Parameters:**

- `ty`: The integer type of both operands
- `lhs`: The dividend
- `rhs`: The divisor

#### `srem : LType -> (LValue False) -> (LValue False) -> LExpr`

Create remainder operation (signed).

Creates a signed integer remainder operation that returns the remainder of signed division.

**Parameters:**

- `ty`: The integer type of both operands
- `lhs`: The dividend
- `rhs`: The divisor

#### `frem : {default [] fastMath : FastMath} -> (ty : LType) -> (lhs : (LValue False)) -> (rhs : (LValue False)) -> LExpr`

Create floating point remainder operation.

Creates a floating-point remainder operation with optional fast math flags.

**Parameters:**

- `fastMath`: Fast math flags for optimization
- `ty`: The floating-point type of both operands
- `lhs`: The dividend
- `rhs`: The divisor

### Wrapped Arithmetic Operations

#### `addWrap : (wrap : Wrapping) -> (ty : LType) -> (lhs : (LValue False)) -> (rhs : (LValue False)) -> LExpr`

Create addition with wrapping flags.

Creates an integer addition operation with specified wrapping behavior for overflow conditions.

**Parameters:**

- `wrap`: Wrapping flags (NoSigned, NoUnsigned, or NoSignedUnsigned)
- `ty`: The integer type of both operands
- `lhs`: The left-hand side operand
- `rhs`: The right-hand side operand

#### `subWrap : (wrap : Wrapping) -> (ty : LType) -> (lhs : (LValue False)) -> (rhs : (LValue False)) -> LExpr`

Create subtraction with wrapping flags.

Creates an integer subtraction operation with specified wrapping behavior for overflow conditions.

**Parameters:**

- `wrap`: Wrapping flags (NoSigned, NoUnsigned, or NoSignedUnsigned)
- `ty`: The integer type of both operands
- `lhs`: The left-hand side operand (minuend)
- `rhs`: The right-hand side operand (subtrahend)

#### `mulWrap : (wrap : Wrapping) -> (ty : LType) -> (lhs : (LValue False)) -> (rhs : (LValue False)) -> LExpr`

Create multiplication with wrapping flags.

Creates an integer multiplication operation with specified wrapping behavior for overflow conditions.

**Parameters:**

- `wrap`: Wrapping flags (NoSigned, NoUnsigned, or NoSignedUnsigned)
- `ty`: The integer type of both operands
- `lhs`: The left-hand side operand
- `rhs`: The right-hand side operand

### Shift Operations

#### `shl : {default Nothing wrap : Maybe Wrapping} -> (ty : LType) -> (value : (LValue False)) -> (amount : (LValue False)) -> LExpr`

Create shift left operation.

Creates a logical left shift operation, optionally with wrapping flags for overflow behavior.

**Parameters:**

- `wrap`: Optional wrapping flags for overflow behavior
- `ty`: The integer type of both operands
- `value`: The value to shift
- `amount`: The number of bits to shift

#### `lshr : {default False exact : Bool} -> (ty : LType) -> (value : (LValue False)) -> (amount : (LValue False)) -> LExpr`

Create logical shift right operation.

Creates a logical right shift operation that fills with zeros. Can be marked as exact if no bits are lost.

**Parameters:**

- `exact`: Whether the shift is exact (no bits lost)
- `ty`: The integer type of both operands
- `value`: The value to shift
- `amount`: The number of bits to shift

#### `ashr : {default False exact : Bool} -> (ty : LType) -> (value : (LValue False)) -> (amount : (LValue False)) -> LExpr`

Create arithmetic shift right operation.

Creates an arithmetic right shift operation that fills with the sign bit. Can be marked as exact if no bits are lost.

**Parameters:**

- `exact`: Whether the shift is exact (no bits lost)
- `ty`: The integer type of both operands
- `value`: The value to shift
- `amount`: The number of bits to shift

#### `shlWrap : (wrap : Wrapping) -> (ty : LType) -> (value : (LValue False)) -> (amount : (LValue False)) -> LExpr`

Create shift left with wrapping flags.

Creates a logical left shift operation with specified wrapping behavior for overflow conditions.

**Parameters:**

- `wrap`: Wrapping flags (NoSigned, NoUnsigned, or NoSignedUnsigned)
- `ty`: The integer type of both operands
- `value`: The value to shift
- `amount`: The number of bits to shift

### Bitwise Operations

#### `and : LType -> (LValue False) -> (LValue False) -> LExpr`

Create bitwise AND operation.

Creates a bitwise AND operation between two integer operands of the same type. Each bit in the result is the logical AND of the corresponding bits in the operands.

**Parameters:**

- `ty`: The integer type of both operands (must be the same)
- `lhs`: The left-hand side operand
- `rhs`: The right-hand side operand

#### `or : {default False disjoint : Bool} -> (ty : LType) -> (lhs : (LValue False)) -> (rhs : (LValue False)) -> LExpr`

Create bitwise OR operation.

Creates a bitwise OR operation between two integer operands of the same type. Each bit in the result is the logical OR of the corresponding bits in the operands. Optionally can be marked as disjoint for optimization.

**Parameters:**

- `disjoint`: Whether the operands are disjoint (no common set bits)
- `ty`: The integer type of both operands (must be the same)
- `lhs`: The left-hand side operand
- `rhs`: The right-hand side operand

#### `xor : LType -> (LValue False) -> (LValue False) -> LExpr`

Create bitwise XOR operation.

Creates a bitwise XOR operation between two integer operands of the same type. Each bit in the result is the logical XOR of the corresponding bits in the operands.

**Parameters:**

- `ty`: The integer type of both operands (must be the same)
- `lhs`: The left-hand side operand
- `rhs`: The right-hand side operand

### Type Conversion Operations

#### `trunc : {default Nothing wrap : Maybe Wrapping} -> (from : WithType (LValue False)) -> (to : LType) -> LExpr`

Create a truncate operation.

Creates a truncation operation that reduces the bit width of an integer value by discarding high-order bits. Can include wrapping flags.

**Parameters:**

- `wrap`: Optional wrapping flags
- `from`: The typed source value with larger bit width
- `to`: The target type with smaller bit width

#### `zext : {t : Bool} -> (from : WithType (LValue t)) -> (to : LType) -> LExpr`

Create a zero extend operation.

Creates a zero extension operation that increases the bit width of an integer value by padding with zeros in the high-order bits.

**Parameters:**

- `from`: The typed source value with smaller bit width
- `to`: The target type with larger bit width

#### `sext : {t : Bool} -> (from : WithType (LValue t)) -> (to : LType) -> LExpr`

Create a sign extend operation.

Creates a sign extension operation that increases the bit width of a signed integer value by replicating the sign bit in the high-order bits.

**Parameters:**

- `from`: The typed source value with smaller bit width
- `to`: The target type with larger bit width

#### `bitcast : {t : Bool} -> (from : WithType (LValue t)) -> (to : LType) -> LExpr`

Create a bitcast operation.

Creates a bitcast operation that reinterprets the bits of a value as a different type without changing the bit pattern. Both types must have the same size.

**Parameters:**

- `from`: The typed source value to reinterpret
- `to`: The target type to reinterpret as

#### `fptrunc : {default [] fastMath : FastMath} -> (from : WithType (LValue False)) -> (to : LType) -> LExpr`

Create a floating point truncate operation.

Creates a floating-point truncation operation that converts from a larger to a smaller floating-point type.

**Parameters:**

- `fastMath`: Fast math flags for optimization
- `from`: The typed source value with larger precision
- `to`: The target type with smaller precision

#### `fpext : {default [] fastMath : FastMath} -> (from : WithType (LValue False)) -> (to : LType) -> LExpr`

Create a floating point extend operation.

Creates a floating-point extension operation that converts from a smaller to a larger floating-point type.

**Parameters:**

- `fastMath`: Fast math flags for optimization
- `from`: The typed source value with smaller precision
- `to`: The target type with larger precision

### Comparison Operations

#### `icmp : (pred : Comparison) -> (ty : LType) -> (lhs : (LValue False)) -> (rhs : (LValue False)) -> LExpr`

Create an integer comparison operation.

Creates an integer comparison operation using the specified predicate. The comparison evaluates to an i1 (boolean) result that can be used in conditional branches and other boolean contexts.

**Parameters:**

- `pred`: The comparison predicate (eq, ne, lt, gt, etc.)
- `ty`: The type of the operands being compared
- `lhs`: The left-hand side operand
- `rhs`: The right-hand side operand

#### `fcmp : (ordered : Bool) -> {default [] fastMath : FastMath} -> (pred : Comparison) -> (ty : LType) -> (lhs : (LValue False)) -> (rhs : (LValue False)) -> LExpr`

Create a floating point comparison operation.

Creates a floating-point comparison operation. Can be either ordered (returns false for NaN inputs) or unordered (returns true for NaN inputs).

**Parameters:**

- `ordered`: Whether the comparison is ordered
- `fastMath`: Fast math flags for optimization
- `pred`: The comparison predicate
- `ty`: The floating-point type of the operands
- `lhs`: The left-hand side operand
- `rhs`: The right-hand side operand

### Specialized Comparison Functions

#### `icmpEq, icmpNe, icmpULt, icmpSLt, icmpUGt, icmpSGt, icmpULe, icmpSLe, icmpUGe, icmpSGe : LType -> (LValue False) -> (LValue False) -> LExpr`

Specialized integer comparison functions for specific predicates:

- `icmpEq`: Equal
- `icmpNe`: Not equal
- `icmpULt`: Unsigned less than
- `icmpSLt`: Signed less than
- `icmpUGt`: Unsigned greater than
- `icmpSGt`: Signed greater than
- `icmpULe`: Unsigned less than or equal
- `icmpSLe`: Signed less than or equal
- `icmpUGe`: Unsigned greater than or equal
- `icmpSGe`: Signed greater than or equal

### Floating-Point Operations

#### `fneg : LType -> (LValue ?) -> LExpr`

Create a floating point negation operation.

Creates a floating-point negation operation that changes the sign of a floating-point value.

**Parameters:**

- `ty`: The floating-point type of the operand
- `operand`: The value to negate

#### `fadd : {default [] fastMath : FastMath} -> (ty : LType) -> (lhs : (LValue False)) -> (rhs : (LValue False)) -> LExpr`

Create floating point addition with fast math flags.

Creates a floating-point addition operation with optional fast math flags for optimization.

**Parameters:**

- `fastMath`: Fast math flags for optimization
- `ty`: The floating-point type of both operands
- `lhs`: The left-hand side operand
- `rhs`: The right-hand side operand

#### `fsub : {default [] fastMath : FastMath} -> (ty : LType) -> (lhs : (LValue False)) -> (rhs : (LValue False)) -> LExpr`

Create floating point subtraction with fast math flags.

Creates a floating-point subtraction operation with optional fast math flags for optimization.

**Parameters:**

- `fastMath`: Fast math flags for optimization
- `ty`: The floating-point type of both operands
- `lhs`: The left-hand side operand (minuend)
- `rhs`: The right-hand side operand (subtrahend)

#### `fmul : {default [] fastMath : FastMath} -> (ty : LType) -> (lhs : (LValue False)) -> (rhs : (LValue False)) -> LExpr`

Create floating point multiplication with fast math flags.

Creates a floating-point multiplication operation with optional fast math flags for optimization.

**Parameters:**

- `fastMath`: Fast math flags for optimization
- `ty`: The floating-point type of both operands
- `lhs`: The left-hand side operand
- `rhs`: The right-hand side operand

## Data.LLVM.Builders.Control

### Function Definition

#### `functionDef : (name : String) -> {default emptySymbolInfo symbolInfo : SymbolInfo} -> {default Nothing callingConvention : Maybe CallingConvention} -> {default [] returnAttrs : List Attribute} -> (retType : LType) -> (args : List Argument) -> {default Nothing addressInfo : Maybe AddressInfo} -> {default Nothing addressSpace : Maybe AddressSpace} -> {default [] fnAttributes : List Attribute} -> {default Nothing section : Maybe String} -> {default Nothing partition : Maybe String} -> {default Nothing comdat : Maybe Name} -> {default Nothing alignment : Maybe Int} -> {default Nothing gc : Maybe String} -> {default Nothing fprefix : Maybe (LValue True)} -> {default Nothing prologue : Maybe (LValue True)} -> {default Nothing personality : Maybe (LValue True)} -> {default [] metadata : List Metadata} -> (body : Table BasicBlock) -> {default neutral tags : Annotation} -> FunctionDef`

Create a function definition with comprehensive configuration options.

Builds a complete function definition with all possible LLVM function attributes and metadata. Most parameters have sensible defaults to reduce verbosity.

**Parameters:**

- `name`: The function name (identifier)
- `symbolInfo`: Symbol information including linkage, preemption, visibility, and storage
- `callingConvention`: The calling convention (C, FastCC, etc.)
- `returnAttrs`: Attributes applied to the return value
- `retType`: The return type of the function
- `args`: List of function argument specifications with types and attributes
- `addressInfo`: Address information for the function
- `addressSpace`: Address space where the function resides
- `fnAttributes`: Function-level attributes (noinline, readonly, etc.)
- `section`: Optional section name for the function
- `partition`: Optional partition name for the function
- `comdat`: Optional COMDAT group name
- `alignment`: Optional function alignment requirement
- `gc`: Optional garbage collector specification
- `fprefix`: Optional function prefix constant
- `prologue`: Optional prologue constant
- `personality`: Optional personality function for exception handling
- `metadata`: List of metadata attached to the function
- `body`: The function body containing statements
- `tags`: Additional tags for the function

### Control Flow

#### `ret : LType -> (LValue _) -> Terminator`

Create a return statement with value.

Creates a return statement that returns a typed value from the current function.

**Parameters:**

- `ty`: The type of the return value
- `value`: The expression representing the value to return

#### `retVoid : Terminator`

Create a void return statement.

Creates a return statement for functions with void return type.

#### `condBr : (LValue _) -> Label -> Label -> Terminator`

Create a conditional branch statement.

Creates a conditional branch that jumps to one of two labels based on a boolean condition.

**Parameters:**

- `cond`: The boolean condition to test
- `trueLabel`: Label to jump to if condition is true
- `falseLabel`: Label to jump to if condition is false

#### `br : Label -> Terminator`

Create an unconditional branch statement.

Creates an unconditional jump to a target label.

**Parameters:**

- `target`: Expression representing the label to jump to

#### `switch : LType -> (LValue _) -> Label -> List CaseBranch -> Terminator`

Create a switch statement.

Creates a switch statement that compares a value against multiple cases and jumps to the corresponding label.

**Parameters:**

- `ty`: The type of the switch expression
- `expr`: The expression to switch on
- `defaultCase`: The default label if no cases match
- `cases`: List of case branches with values and labels

#### `indirectBr : (LValue _) -> (List (LValue _)) -> Terminator`

Create an indirect branch through computed address.

Creates an indirect branch instruction that jumps to an address computed at runtime.

**Parameters:**

- `address`: Expression that computes the target address at runtime
- `possibleDests`: List of possible destination labels for static analysis

### Exception Handling

#### `invoke : InvokeCall -> Terminator`

Create an invoke instruction for exception handling.

Creates an invoke instruction that calls a function with exception handling, specifying both normal and exceptional control flow.

**Parameters:**

- `invokeCall`: The invoke call specification with function, arguments, and labels

#### `resume : LType -> (LValue _) -> Terminator`

Create a resume instruction for exception propagation.

Creates a resume instruction that propagates an exception value up the call stack.

**Parameters:**

- `ty`: The type of the exception value
- `value`: The exception value to propagate

#### `catchRet : (LValue _) -> Label -> Terminator`

Create a catch return instruction.

Creates a catch return instruction that returns from a catch block to a specified label.

**Parameters:**

- `value`: The value from the catch operation
- `label`: The label to return to

#### `cleanupRet : (LValue _) -> Label -> Terminator`

Create a cleanup return to specific label.

Creates a cleanup return instruction that returns from a cleanup block to a specified label.

**Parameters:**

- `value`: The value from the cleanup operation
- `label`: The label to return to

#### `cleanupRetCaller : (LValue _) -> Terminator`

Create a cleanup return to caller.

Creates a cleanup return instruction that returns to the caller.

**Parameters:**

- `value`: The value from the cleanup operation

#### `landingPad : LType -> List CatchClause -> LExpr`

Create a landing pad instruction.

Creates a landing pad instruction for exception handling that specifies catch clauses.

**Parameters:**

- `ty`: The type of the landing pad
- `clauses`: List of catch clauses

#### `landingPadCleanup : LType -> List CatchClause -> LExpr`

Create a landing pad with cleanup.

Creates a landing pad instruction with cleanup semantics.

**Parameters:**

- `ty`: The type of the landing pad
- `clauses`: List of catch clauses

#### `catchPad : Name -> (LValue _) -> LExpr`

Create a catch pad instruction.

Creates a catch pad instruction for structured exception handling.

**Parameters:**

- `name`: The name for the catch pad
- `value`: The associated value

#### `cleanupPad : Name -> (LValue _) -> LExpr`

Create a cleanup pad instruction.

Creates a cleanup pad instruction for structured exception handling.

**Parameters:**

- `name`: The name for the cleanup pad
- `value`: The associated value

### Memory Operations

#### `alloca : (ty : LType) -> {default Nothing count : Maybe (WithType Nat)} -> {default Nothing align : Maybe Nat} -> {default Nothing addrSpace : Maybe AddressSpace} -> LExpr`

Create a stack allocation (alloca) instruction.

Creates an alloca instruction that allocates memory on the function's stack frame. The memory is automatically deallocated when the function returns.

**Parameters:**

- `ty`: The type of objects to allocate
- `count`: Optional number of objects to allocate (defaults to single object)
- `align`: Optional alignment requirement for the allocation
- `addrSpace`: Optional address space for the allocation

#### `load : {default False volatile : Bool} -> (ty : LType) -> (ptr : (LValue _)) -> {default Nothing align : Maybe Nat} -> LExpr`

Create a simple load operation.

Creates a load instruction that reads a value from memory. The pointer must point to a valid memory location containing a value of the specified type.

**Parameters:**

- `volatile`: Whether this is a volatile load (prevents optimization)
- `ty`: The type of the value to load from memory
- `ptr`: Expression representing the pointer to load from
- `align`: Optional alignment requirement for the load

#### `store : {default False volatile : Bool} -> (value : WithType (LValue _)) -> (ptr : (LValue _)) -> {default Nothing align : Maybe Nat} -> LExpr`

Create a simple store operation.

Creates a store instruction that writes a typed value to memory at the specified pointer location.

**Parameters:**

- `volatile`: Whether this is a volatile store (prevents optimization)
- `value`: The typed value to store in memory
- `ptr`: Expression representing the pointer to store to
- `align`: Optional alignment requirement for the store

#### `loadAtomic : {default False volatile : Bool} -> (ty : LType) -> (ptr : (LValue _)) -> {default Nothing scope : Maybe String} -> {default Nothing ordering : Maybe AtomicOrder} -> {default Nothing align : Maybe Nat} -> LExpr`

Create an atomic load operation.

Creates an atomic load instruction with specified memory ordering semantics.

**Parameters:**

- `volatile`: Whether this is a volatile load
- `ty`: The type of the value to load
- `ptr`: The pointer to load from
- `scope`: Optional synchronization scope
- `ordering`: Optional atomic ordering constraint
- `align`: Optional alignment requirement

#### `storeAtomic : {default False volatile : Bool} -> (value : WithType (LValue _)) -> (ptr : (LValue _)) -> {default Nothing scope : Maybe String} -> {default Nothing ordering : Maybe AtomicOrder} -> {default Nothing align : Maybe Nat} -> LExpr`

Create an atomic store operation.

Creates an atomic store instruction with specified memory ordering semantics.

**Parameters:**

- `volatile`: Whether this is a volatile store
- `value`: The typed value to store
- `ptr`: The pointer to store to
- `scope`: Optional synchronization scope
- `ordering`: Optional atomic ordering constraint
- `align`: Optional alignment requirement

### Function Calls

#### `call : {default Nothing cc : Maybe CallingConvention} -> {default [] attrs : List Attribute} -> {default Nothing addrSpace : Maybe AddressSpace} -> (ty : LType) -> (fn : (LValue _)) -> (args : List (LValue _)) -> LExpr`

Create a function call instruction.

Creates a function call instruction with optional calling convention and attributes.

**Parameters:**

- `cc`: Optional calling convention
- `attrs`: Optional attributes for the call
- `addrSpace`: Optional address space
- `ty`: The function type
- `fn`: The function to call
- `args`: List of arguments to pass

#### `invokeCall : {default Nothing cc : Maybe CallingConvention} -> {default [] returnAttrs : List Attribute} -> {default Nothing addressSpace : Maybe AddressSpace} -> (tpe : LType) -> (fnval : (LValue _)) -> (args : List (LValue _)) -> (normal : Label) -> (unwind : Label) -> InvokeCall`

Create an invoke call specification.

Creates an invoke call specification for exception-aware function calls.

**Parameters:**

- `cc`: Optional calling convention
- `returnAttrs`: Optional return value attributes
- `addressSpace`: Optional address space
- `tpe`: The function type
- `fnval`: The function to call
- `args`: List of arguments to pass
- `normal`: Label for normal return
- `unwind`: Label for exceptional return

### Vector Operations

#### `insertElement : {t0, t1, t2 : Bool} -> (vector : WithType (LValue t0)) -> (element : WithType (LValue t1)) -> (index : WithType (LValue t2)) -> LExpr`

Create an insert element operation.

Creates an operation that inserts a scalar element into a vector at the specified index position.

**Parameters:**

- `vector`: The typed source vector to insert into
- `element`: The typed scalar element to insert
- `index`: The typed index expression specifying the insertion position

#### `extractElement : (vector : WithType (LValue _)) -> (index : WithType (LValue _)) -> LExpr`

Create an extract element operation.

Creates an operation that extracts a scalar element from a vector at the specified index position.

**Parameters:**

- `vector`: The typed source vector to extract from
- `index`: The typed index expression specifying the extraction position

#### `shuffleVector : (vec1 : WithType (LValue _)) -> (vec2 : WithType (LValue _)) -> (mask : WithType (LValue _)) -> LExpr`

Create a shuffle vector operation.

Creates an operation that shuffles elements from two input vectors according to a mask vector.

**Parameters:**

- `vec1`: The first typed input vector
- `vec2`: The second typed input vector
- `mask`: The typed mask vector specifying the shuffle pattern

### Aggregate Operations

#### `extractValue : (aggregate : WithType (LValue _)) -> (index : Nat) -> LExpr`

Create an extract value operation.

Creates an operation that extracts a value from an aggregate type (struct or array) at the specified index.

**Parameters:**

- `aggregate`: The typed aggregate value to extract from
- `index`: The constant index specifying which field/element to extract

#### `insertValue : (aggregate : WithType (LValue _)) -> (element : WithType (LValue _)) -> (index : Nat) -> LExpr`

Create an insert value operation.

Creates an operation that inserts a value into an aggregate type (struct or array) at the specified index, returning a new aggregate with the updated value.

**Parameters:**

- `aggregate`: The typed aggregate value to insert into
- `element`: The typed value to insert
- `index`: The constant index specifying where to insert the value

### SSA and Control Flow

#### `phi : (ty : LType) -> (incomingValues : List ((LValue _), Label)) -> LExpr`

Create a PHI node.

Creates a PHI node for SSA form that selects a value based on which basic block was the predecessor.

**Parameters:**

- `ty`: The type of all the incoming values (must be the same)
- `incomingValues`: List of (value, label) pairs for each predecessor block

#### `select : {default [] fastMath : FastMath} -> (condition : WithType (LValue _)) -> (trueValue : WithType (LValue _)) -> (falseValue : WithType (LValue _)) -> LExpr`

Create a select operation.

Creates a conditional select operation that chooses between two values based on a boolean condition.

**Parameters:**

- `fastMath`: Optional fast math flags for floating point operations
- `condition`: The typed boolean condition to test
- `trueValue`: The typed value to select if condition is true
- `falseValue`: The typed value to select if condition is false

#### `freeze : (value : WithType (LValue _)) -> LExpr`

Create a freeze operation.

Creates a freeze operation that converts poison values to arbitrary but fixed values.

**Parameters:**

- `value`: The typed value to freeze

### Utility Functions

#### `caseBranch : (tpe : LType) -> (value : (LValue True)) -> (label : Label) -> CaseBranch`

Create a case branch for switch statements.

Defines a single case in a switch statement, mapping a value of a specific type to a target label.

**Parameters:**

- `tpe`: The type of the case value (must match switch expression type)
- `value`: The constant value to match against
- `label`: The target label to jump to when this case matches

#### `argument : (ty : LType) -> {default [] attrs : List Attribute} -> {default Nothing name : Maybe String} -> Argument`

Create a function argument specification with optional attributes and name.

Creates a function argument specification that includes type information, optional parameter attributes, and an optional parameter name.

**Parameters:**

- `ty`: The type of the function parameter
- `attrs`: Optional attributes applied to this parameter
- `name`: Optional parameter name for readability and debugging

## Data.LLVM.Builders.Ops

### Global Variable Definitions

#### `globalDef : (name : String) -> {default emptySymbolInfo symbolInfo : SymbolInfo} -> {default Nothing threadLocality : Maybe ThreadLocality} -> {default Nothing addressInfo : Maybe AddressInfo} -> {default Nothing addressSpace : Maybe AddressSpace} -> {default False externallyInitialized : Bool} -> {default False isConst : Bool} -> (ty : LType) -> {default Nothing init : Maybe (LValue True)} -> {default Nothing section : Maybe String} -> {default Nothing partition : Maybe String} -> {default Nothing comdat : Maybe Name} -> {default Nothing alignment : Maybe Int} -> {default [] metadata : List Metadata} -> {default neutral tags : Annotation} -> GlobalDef`

Make a global variable definition with configurable options.

Creates a global variable definition with comprehensive configuration options including symbol information, thread locality, address space, and initialization settings.

**Parameters:**

- `name`: The global variable name (identifier)
- `symbolInfo`: Symbol information including linkage, preemption, visibility, and storage
- `threadLocality`: Thread-local storage model if applicable
- `addressInfo`: Address information for the global variable
- `addressSpace`: Address space where the global variable resides
- `externallyInitialized`: Whether the variable is initialized externally
- `isConst`: Whether the variable is constant (read-only)
- `ty`: The type of the global variable
- `init`: Optional initial value for the variable
- `section`: Optional section name for the variable
- `partition`: Optional partition name for the variable
- `comdat`: Optional COMDAT group name
- `alignment`: Optional alignment requirement
- `metadata`: List of metadata attached to the variable
- `tags`: Additional tags for the variable

### Function Declarations

#### `functionDecl : (name : String) -> {default emptySymbolInfo symbolInfo : SymbolInfo} -> {default Nothing callingConvention : Maybe CallingConvention} -> {default [] returnAttrs : List Attribute} -> (returnType : LType) -> (args : List LType) -> {default Nothing addressInfo : Maybe AddressInfo} -> {default Nothing addressSpace : Maybe AddressSpace} -> {default [] fnAttributes : List Attribute} -> {default Nothing section : Maybe String} -> {default Nothing partition : Maybe String} -> {default Nothing comdat : Maybe Name} -> {default Nothing alignment : Maybe Int} -> {default Nothing gc : Maybe String} -> {default Nothing fprefix : Maybe (LValue True)} -> {default Nothing prologue : Maybe (LValue True)} -> {default neutral tags : Annotation} -> FunctionDec`

Create a function declaration with comprehensive configuration options.

Creates a function declaration (forward declaration) with all possible LLVM function attributes. This is used for functions defined elsewhere or external functions.

**Parameters:**

- `name`: The function name (identifier)
- `symbolInfo`: Symbol information including linkage, preemption, visibility, and storage
- `callingConvention`: The calling convention (C, FastCC, etc.)
- `returnAttrs`: Attributes applied to the return value
- `returnType`: The return type of the function
- `args`: List of parameter types (names not needed for declarations)
- `addressInfo`: Address information for the function
- `addressSpace`: Address space where the function resides
- `fnAttributes`: Function-level attributes
- `section`: Optional section name for the function
- `partition`: Optional partition name for the function
- `comdat`: Optional COMDAT group name
- `alignment`: Optional function alignment requirement
- `gc`: Optional garbage collector specification
- `fprefix`: Optional function prefix constant
- `prologue`: Optional prologue constant
- `tags`: Additional tags for the function

### Advanced Constructs

#### `alias : (name : String) -> {default emptySymbolInfo symbolInfo : SymbolInfo} -> {default Nothing threadLocality : Maybe ThreadLocality} -> {default Nothing addressInfo : Maybe AddressInfo} -> (aliaseeType : LType) -> (aliasee : (LValue True)) -> {default Nothing partition : Maybe String} -> {default neutral tags : Annotation} -> Alias`

Create an alias definition.

Creates an alias that provides an alternative name for an existing global value.

**Parameters:**

- `name`: The alias name
- `symbolInfo`: Symbol information for the alias
- `threadLocality`: Thread-local storage model if applicable
- `addressInfo`: Address information for the alias
- `aliaseeType`: The type of the value being aliased
- `aliasee`: The value being aliased
- `partition`: Optional partition name
- `tags`: Additional tags

#### `ifunc : (name : String) -> {default emptySymbolInfo symbolInfo : SymbolInfo} -> {default Nothing threadLocality : Maybe ThreadLocality} -> {default Nothing addressInfo : Maybe AddressInfo} -> (funTpe : LType) -> (resTpe : LType) -> (resolver : String) -> {default neutral tags : Annotation} -> IFunc`

Create an indirect function (IFunc) definition.

Creates an IFunc that provides runtime selection of function implementations.

**Parameters:**

- `name`: The IFunc name
- `symbolInfo`: Symbol information for the IFunc
- `threadLocality`: Thread-local storage model if applicable
- `addressInfo`: Address information for the IFunc
- `funTpe`: The function type
- `resTpe`: The resolver function type
- `resolver`: The name of the resolver function
- `tags`: Additional tags

## Data.LLVM.Builders.Helper

### Type Reflection

#### `lowerTypeReflect : (a : Type) -> LType`

Type reflection helper for converting Idris types to LLVM types.

Maps common Idris types to their LLVM equivalents:

- `Int` → i32
- `Double` → double
- `String` → ptr
- `Bool` → i1
- `Int8` → i8
- `Int16` → i16
- `Int32` → i32
- `Int64` → i64

**Parameters:**

- `a`: The Idris type to reflect

### Utility Functions

#### `indexed : List a -> List (a, Nat)`

Helper function to add indices to a list.

Creates a list of pairs where each element is paired with its index position starting from 0. Used internally for generating unique labels in control flow constructs.

**Parameters:**

- `xs`: The list to index

#### `bytecode : {default Nothing mainMod : Maybe String} -> {default [] modules : List (String, LModule)} -> Bytecode`

Create a bytecode specification with main module and additional modules.

Creates a bytecode specification that can contain multiple LLVM modules with an optional main module designation.

**Parameters:**

- `mainMod`: Optional name of the main module
- `modules`: List of (name, module) pairs for all modules in the bytecode

#### `foreignDecl : String -> LType -> List LType -> LClause`

Create a foreign function declaration clause.

Creates a clause for declaring external functions that are defined in other languages or libraries.

**Parameters:**

- `name`: The name of the foreign function
- `returnType`: The return type of the function
- `paramTypes`: List of parameter types

## Data.LLVM.Builders.Inst

### Setter Implementations

This module provides `Setter` interface implementations for all record types in the LLVM IR hierarchy. These enable the use of the syntactic sugar operators like `&=`, `&-`, `&+`, and `&?` for modifying record fields.

The module includes setter implementations for:

- **SymbolInfo**: linkage, visibility, preemption, DLL storage
- **CaseBranch**: type, value, label  
- **InvokeCall**: calling convention, attributes, address space, etc.
- **BrCall**: calling convention, attributes, function type, etc.
- **FnCall**: tail call flags, fast math, calling convention, etc.
- **FunctionDef**: all function definition fields
- **FunctionDec**: all function declaration fields
- **GlobalDef**: all global definition fields
- **Alias**: name, symbol info, thread locality, etc.
- **IFunc**: all indirect function fields
- **AttributeGroupDef**: name and attributes
- **LModule**: data layout, target, text, annotation

These setters enable fluent-style record updates using the modifier operators from the Sugar module.

## Usage Examples

### Complete Function with Multiple Operations

```idris
exampleFunction = functionDef "compute" i32 [
    "x" !^ i32,
    "y" !^ i32
] $ [
    "entry" !: ([
        "sum" <<- (add i32 (?^ "x") (?^ "y")),
        "diff" <<- (sub i32 (?^ "x") (?^ "y")),
        "product" <<- (mul i32 (?^ "sum") (?^ "diff")),
        "is_positive" <<- (icmpSGt i32 (?^ "product") (## 0))
    ], condBr (?^ "is_positive") (#^ "positive") (#^ "negative")),
    
    "positive" !: ([
        "result" <<- (udiv i32 (?^ "product") (## 2))
    ], ret i32 (?^ "result")),
    
    "negative" !: ([
        "negated" <<- (sub i32 (## 0) (?^ "product"))
    ], ret i32 (?^ "negated"))
]
```

### Module with Global Variables and Functions

```idris
exampleModule = MkLModule {
    dataLayout = Just "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128",
    target = Just "x86_64-unknown-linux-gnu",
    text = [
        GlobalDefC $ globalDef "counter" i32 {init = Just (## 0)},
        GlobalDefC $ globalDef "PI" double {init = Just (mkFloat "3.14159"), isConst = True},
        FunctionDefC exampleFunction
    ]
}
```

### Vector and Aggregate Operations

```idris
vectorOperations = [
    "vec1" <<- (insertElement 
        ((4 :<> i32) <::> undef) 
        ((## 42) <:> i32) 
        ((## 0) <:> i32)),
    "vec2" <<- (insertElement 
        ((?^ "vec1") <:> (4 :<> i32)) 
        ((## 24) <:> i32) 
        ((## 1) <:> i32)),
    "elem" <<- (extractElement 
        ((?^ "vec2") <:> (4 :<> i32)) 
        ((## 0) <:> i32)),
    "shuffled" <<- (shuffleVector 
        ((?^ "vec1") <:> (4 :<> i32))
        ((?^ "vec2") <:> (4 :<> i32))
        ((## 0) <:> (4 :<> i32)))
]
```

This comprehensive reference covers all major builder functions available in the LLVM IR Builders module, providing type-safe and convenient ways to construct LLVM IR programmatically.